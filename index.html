<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Use a game-like font */
        body {
            font-family: 'Inter', sans-serif; /* A more modern, clean font */
            touch-action: manipulation; /* Prevents double-tap to zoom on buttons */
            -webkit-tap-highlight-color: transparent; /* Removes tap highlight on mobile */
            overflow: hidden; /* Prevent scrolling */
        }
        /* Custom styles for the game canvas */
        #game-canvas {
            /* New Gradient Background */
            background: linear-gradient(135deg, #371f47 0%, #111827 60%, #000000 100%);
            border-radius: 0.5rem;
            display: block; /* Ensures it behaves as a block element */
            transform-origin: center center; /* Ensure animations scale from the center */
        }
        /* Style for the control buttons for a tactile feel */
        .control-btn {
            transition: transform 0.1s ease;
        }

        /* Animation class for button press */
        .animate-press {
            animation: press-animation 0.2s ease-out;
        }

        @keyframes press-animation {
            0% { transform: scale(1); filter: brightness(100%); }
            50% { transform: scale(0.85); filter: brightness(160%); }
            100% { transform: scale(1); filter: brightness(100%); }
        }
        
        /* Screen shake animation for player getting hit */
        .shake-hard { animation: shake-hard-animation 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake-hard-animation {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Health bar container flash on hit */
        .health-flash {
            animation: health-flash-animation 0.4s ease-out;
        }
        @keyframes health-flash-animation {
            0%, 100% { box-shadow: 0 0 0 0px rgba(239, 68, 68, 0); }
            50% { box-shadow: 0 0 20px 8px rgba(239, 68, 68, 0.7); }
        }

        /* Shield bar container flash on hit */
        .shield-flash {
            animation: shield-flash-animation 0.4s ease-out;
        }
        @keyframes shield-flash-animation {
            0%, 100% { box-shadow: 0 0 0 0px rgba(59, 130, 246, 0); }
            50% { box-shadow: 0 0 20px 8px rgba(59, 130, 246, 0.7); }
        }

        /* Special attack flash */
        .special-attack-flash {
             animation: special-attack-flash-animation 0.5s ease-out;
        }
        @keyframes special-attack-flash-animation {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(253, 224, 71, 0.5); }
        }


        /* CRT Filter Styles */
        .crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            pointer-events: none; z-index: 9999;
        }
        .crt-overlay::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 200%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0, rgba(0,0,0,0.3) 1.5px, rgba(0,0,0,0.1) 3px);
            animation: scanline 10s linear infinite;
        }
        @keyframes scanline { from { transform: translateY(0); } to { transform: translateY(-50%); } }
        .crt-overlay::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6));
            opacity: 0.7;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex flex-col antialiased">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full h-full max-w-md mx-auto flex flex-col p-4">

        <!-- Header: Game Stats -->
        <header class="flex-shrink-0 flex w-full rounded-lg mb-4 overflow-hidden h-12 shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899]">
            <!-- Health Meter -->
            <div class="flex-1 bg-red-950 relative flex items-center justify-center">
                <div id="health-bar" class="bg-red-500 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ù§Ô∏è</span>
                </div>
            </div>

            <!-- Player Special Meter -->
            <div class="flex-1 bg-yellow-900 relative flex items-center justify-center">
                <div id="energy-bar" class="bg-yellow-400 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ú®</span>
                </div>
            </div>

            <!-- Shield Meter -->
            <div class="flex-1 bg-blue-950 relative flex items-center justify-center">
                <div id="shield-bar" class="bg-sky-400 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">üõ°Ô∏è</span>
                </div>
            </div>
        </header>

        <!-- Equipment Slots -->
        <div id="equipment-bar" class="flex-shrink-0 my-4">
            <!-- Slots Container -->
            <div class="grid grid-cols-4 gap-3">
                <!-- Slot 1 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üó°Ô∏è</span></div>
                <!-- Slot 2 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üîÆ</span></div>
                <!-- Slot 3 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üçé</span></div>
                <!-- Slot 4 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üçû</span></div>
            </div>
        </div>

        <!-- Game Canvas Area -->
        <main class="flex-grow flex items-center justify-center relative">
             <div id="canvas-wrapper" class="relative w-full h-full flex items-center justify-center">
                <canvas id="game-canvas"></canvas>
                <!-- Enemy Status Bars -->
                <div id="enemy-stats" class="absolute top-4 w-3/4 max-w-xs h-5 flex rounded-lg overflow-hidden shadow-lg border-2 border-gray-700 opacity-0 transition-opacity duration-300">
                    <!-- Enemy Health -->
                    <div class="flex-1 bg-red-950 relative flex items-center justify-center">
                        <div id="enemy-health-bar" class="bg-red-500 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                        <div class="relative z-10 flex items-center text-base" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ù§Ô∏è</div>
                    </div>
                    <!-- Enemy Special -->
                    <div class="flex-1 bg-yellow-900 relative flex items-center justify-center">
                        <div id="enemy-special-bar" class="bg-yellow-400 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                         <div class="relative z-10 flex items-center text-base" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ö°</div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Controls Area -->
        <footer class="flex-shrink-0 mt-4 flex justify-center items-center space-x-4">
            <!-- Action Button -->
            <button id="action-btn-a" class="w-24 h-24 bg-purple-600 rounded-full flex items-center justify-center control-btn shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899]">
            </button>
            <!-- Special Attack Button -->
            <button id="special-attack-btn" class="w-16 h-16 bg-yellow-500 rounded-full flex items-center justify-center control-btn shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899]">
            </button>
        </footer>

    </div>

    <!-- CRT Filter Overlay -->
    <div class="crt-overlay"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const main = document.querySelector('main');
            const gameContainer = document.getElementById('game-container');
            const healthBar = document.getElementById('health-bar');
            const energyBar = document.getElementById('energy-bar');
            const shieldBar = document.getElementById('shield-bar');
            const actionButton = document.getElementById('action-btn-a');
            const specialAttackButton = document.getElementById('special-attack-btn');
            const enemyStats = document.getElementById('enemy-stats');
            const enemyHealthBar = document.getElementById('enemy-health-bar');
            const enemySpecialBar = document.getElementById('enemy-special-bar');

            // --- Game State ---
            let player = { health: 10, maxHealth: 10, armor: 5, maxArmor: 5, specialPoints: 3, maxSpecialPoints: 3 };
            const enemies = ['üëπ', 'üëª', 'üíÄ', 'üëΩ', 'ü§ñ', 'üéÉ', 'ü§°', 'üòà', 'üê≤'];
            const slotSymbols = ['‚ùå', '‚ö°'];
            let currentEnemyIndex = 0;
            let enemy = null; 
            let gameOver = false;
            let gameWon = false;
            let isAnimating = false;
            let slotEffect = null;

            // --- Helper Functions ---
            function triggerAnimation(element, className) {
                element.classList.remove(className);
                void element.offsetWidth; 
                element.classList.add(className);
                element.addEventListener('animationend', () => {
                    element.classList.remove(className);
                }, { once: true });
            }
            
            // --- Easing function for smooth animations ---
            function easeInCubic(t) { return t * t * t; }
            function easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            // --- UI Update ---
            function updateMeters() {
                const healthPercent = (player.health / player.maxHealth) * 100;
                const armorPercent = (player.armor / player.maxArmor) * 100;
                const specialPercent = (player.specialPoints / player.maxSpecialPoints) * 100;
                healthBar.style.width = `${healthPercent}%`;
                shieldBar.style.width = `${armorPercent}%`;
                energyBar.style.width = `${specialPercent}%`;
            }

            function updateEnemyMeters() {
                if (!enemy) {
                    enemyStats.classList.add('opacity-0');
                    return;
                }
                enemyStats.classList.remove('opacity-0');
                const healthPercent = (enemy.hp / enemy.maxHp) * 100;
                const specialPercent = (enemy.specialPoints / enemy.maxSpecialPoints) * 100;
                enemyHealthBar.style.width = `${healthPercent}%`;
                enemySpecialBar.style.width = `${specialPercent}%`;
            }

            // --- Canvas Sizing ---
            function resizeCanvas() {
                const mainRect = document.getElementById('canvas-wrapper').getBoundingClientRect();
                const size = Math.min(mainRect.width, mainRect.height) * 0.9;
                canvas.width = size;
                canvas.height = size;
            }

            // --- Animation Controller ---
            function updateEnemyAnimation() {
                if (!enemy || !enemy.animation) return;

                const anim = enemy.animation;
                anim.frame++;
                const progress = Math.min(anim.frame / anim.duration, 1);

                if (anim.type === 'appear') {
                    const t = easeOutBack(progress);
                    enemy.scale = t;
                    enemy.opacity = progress;
                    enemy.rotation = (1 - t) * -90; 
                } else if (anim.type === 'die') {
                    const t = easeInCubic(progress);
                    enemy.scale = 1 + t * 1.5;
                    enemy.rotation = t * 720;
                    enemy.opacity = 1 - progress;
                } else if (anim.type === 'hit') {
                    const t = Math.sin(progress * Math.PI * 4); // Fast oscillation
                    enemy.xOffset = t * 10;
                } else if (anim.type === 'attack') {
                    const progressMid = Math.abs(progress - 0.5) * 2;
                    const t = 1 - progressMid;
                    enemy.yOffset = t * 30;
                    enemy.scale = 1 + t * 0.2;
                }

                if (anim.frame >= anim.duration) {
                    enemy.animation = null;
                    enemy.xOffset = 0;
                    enemy.yOffset = 0;
                    enemy.scale = 1;
                    if (anim.onComplete) anim.onComplete();
                }
            }
            
            // --- Game Drawing Loop ---
            function gameLoop() {
                updateEnemyAnimation();

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (gameOver) {
                    // ... game over text ...
                } else if (gameWon) {
                    // ... you win text ...
                } else if (enemy) {
                    ctx.save();
                    ctx.globalAlpha = enemy.opacity;
                    const centerX = canvas.width / 2 + enemy.xOffset;
                    const centerY = canvas.height / 2 + enemy.yOffset;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(enemy.rotation * Math.PI / 180);
                    ctx.scale(enemy.scale, enemy.scale);
                    const enemyFontSize = canvas.width * 0.4;
                    ctx.font = `${enemyFontSize}px sans-serif`;
                    ctx.fillText(enemy.emoji, 0, 0);
                    ctx.restore();
                }

                // --- Draw Slot Effect ---
                if (slotEffect) {
                    if(slotEffect.isSpinning && slotEffect.life % 2 === 0) {
                        slotEffect.currentSymbol = slotSymbols[Math.floor(Math.random() * 2)];
                    }
                    slotEffect.life++;
                    
                    const animProgress = Math.min(slotEffect.life / slotEffect.duration, 1);
                    
                    let opacity = 0;
                    let scale = 0;

                    if (slotEffect.state === 'appearing') {
                        const t = easeOutBack(animProgress);
                        opacity = t;
                        scale = t;
                    } else if (slotEffect.state === 'holding') {
                        opacity = 1;
                        scale = 1;
                        if (slotEffect.isSpecial) {
                            // Pulsing glow effect
                            const glowProgress = (slotEffect.life % 30) / 30; // 0.5s pulse
                            const pulse = Math.sin(glowProgress * Math.PI);
                            ctx.shadowBlur = 10 + pulse * 15;
                            ctx.shadowColor = 'rgba(253, 224, 71, 1)';
                        }
                    } else if (slotEffect.state === 'fading') {
                        opacity = 1 - animProgress;
                        scale = 1;
                    }
                    
                    ctx.save();
                    const slotSize = canvas.width * 0.15;
                    ctx.font = `${slotSize}px sans-serif`;
                    ctx.globalAlpha = opacity;
                    
                    const centerX = slotEffect.x;
                    const centerY = slotEffect.y;
                    
                    ctx.translate(centerX, centerY);
                    ctx.scale(scale, scale);
                    
                    // Draw slot machine background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.strokeStyle = '#FDE047';
                    ctx.lineWidth = 4;
                    const boxWidth = slotSize * 1.2;
                    const boxHeight = slotSize * 1.2;
                    ctx.beginPath();
                    ctx.roundRect(-boxWidth/2, -boxHeight/2, boxWidth, boxHeight, [10]);
                    ctx.fill();
                    ctx.stroke();

                    // Draw symbol
                    ctx.fillStyle = slotEffect.isSpecial ? '#FDE047' : '#FFFFFF';
                    ctx.fillText(slotEffect.currentSymbol, 0, 0);
                    ctx.restore();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            function createEnemy(index) {
                return {
                    hp: 3 + index, maxHp: 3 + index,
                    specialPoints: 3, maxSpecialPoints: 3,
                    emoji: enemies[index],
                    scale: 0, rotation: 0, opacity: 0, xOffset: 0, yOffset: 0,
                    animation: null
                };
            }
            
            function playEnemyAnimation(type) {
                if (!enemy) return Promise.resolve();
                return new Promise(resolve => {
                    let duration = 1;
                    if (type === 'hit') duration = 18;
                    else if (type === 'die') duration = 30;
                    else if (type === 'appear') duration = 24;
                    else if (type === 'attack') duration = 24;
                    enemy.animation = { type, duration, frame: 0, onComplete: resolve };
                });
            }

            function playSlotSpinAnimation() {
                return new Promise(resolve => {
                    // 1. Appear
                    slotEffect = {
                        x: canvas.width * 0.75,
                        y: canvas.height * 0.65,
                        isSpinning: true,
                        isSpecial: false,
                        currentSymbol: '‚ùå',
                        life: 0,
                        duration: 30, // Appear duration in frames
                        state: 'appearing'
                    };
                    
                    // 2. Stop spinning and show result
                    setTimeout(() => {
                        slotEffect.isSpinning = false;
                        const spinResult = Math.random() < 0.2 ? '‚ö°' : '‚ùå'; // 20% chance for special
                        slotEffect.currentSymbol = spinResult;
                        slotEffect.isSpecial = spinResult === '‚ö°';
                        slotEffect.state = 'holding';
                        slotEffect.life = 0; // Reset life for next state
                        const holdDuration = slotEffect.isSpecial ? 1000 : 400;
                        slotEffect.duration = (holdDuration / 1000) * 60;

                        // 3. Fade out
                        setTimeout(() => {
                            slotEffect.state = 'fading';
                            slotEffect.life = 0; // Reset life
                            slotEffect.duration = 20; // Fade duration in frames

                            // 4. Clean up and resolve
                            setTimeout(() => {
                                slotEffect = null;
                                resolve(spinResult);
                            }, 350);

                        }, holdDuration);

                    }, 800); // Spinning duration
                });
            }

            async function spawnNextEnemy() {
                player.armor = player.maxArmor;
                updateMeters();

                currentEnemyIndex++;
                if (currentEnemyIndex >= enemies.length) {
                    gameWon = true;
                } else {
                    enemy = createEnemy(currentEnemyIndex);
                    updateEnemyMeters();
                    await playEnemyAnimation('appear');
                }
            }

            async function handlePlayerAttack(damage) {
                if (isAnimating || gameOver || gameWon || !enemy) return;
                isAnimating = true;

                await playEnemyAnimation('hit');
                
                enemy.hp -= damage;
                updateEnemyMeters();
                
                if (enemy.hp <= 0) {
                    await playEnemyAnimation('die');
                    enemy = null;
                    updateEnemyMeters();
                    await new Promise(r => setTimeout(r, 200));
                    await spawnNextEnemy();
                } else {
                    // Enemy turn
                    await new Promise(r => setTimeout(r, 200));
                    if (gameOver) {
                        isAnimating = false;
                        return;
                    }

                    const spinResult = await playSlotSpinAnimation();
                    
                    playEnemyAnimation('attack');
                    triggerAnimation(gameContainer, 'shake-hard');
                    
                    const isSpecialAttack = spinResult === '‚ö°' && enemy.specialPoints > 0;
                    const enemyDamage = isSpecialAttack ? 3 : 1;

                    if (isSpecialAttack) {
                        enemy.specialPoints--;
                        triggerAnimation(main, 'special-attack-flash');
                    }
                    
                    const damageToArmor = Math.min(player.armor, enemyDamage);
                    const damageToHealth = enemyDamage - damageToArmor;

                    player.armor -= damageToArmor;
                    player.health -= damageToHealth;

                    if (!isSpecialAttack) {
                        if (damageToHealth > 0) triggerAnimation(healthBar.parentElement, 'health-flash');
                        if (damageToArmor > 0) triggerAnimation(shieldBar.parentElement, 'shield-flash');
                    }
                    
                    updateEnemyMeters();
                    updateMeters();

                    if (player.health <= 0) {
                        player.health = 0;
                        updateMeters();
                        gameOver = true;
                    }
                }
                
                await new Promise(r => setTimeout(r, 400));
                isAnimating = false;
            }

            // --- Event Listeners ---
            actionButton.addEventListener('click', async () => {
                triggerAnimation(actionButton, 'animate-press');
                await handlePlayerAttack(1);
            });

            specialAttackButton.addEventListener('click', async () => {
                if (player.specialPoints > 0 && !isAnimating) {
                    player.specialPoints--;
                    updateMeters();
                    triggerAnimation(specialAttackButton, 'animate-press');
                    await handlePlayerAttack(3);
                }
            });

            // --- Initial Setup ---
            async function init() {
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();
                updateMeters();
                enemy = createEnemy(currentEnemyIndex);
                updateEnemyMeters();
                gameLoop();
                await new Promise(r => setTimeout(r, 200));
                await playEnemyAnimation('appear');
            }
            
            init();
        });
    </script>

</body>
</html>




