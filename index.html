<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Ensures the layout takes up the full screen height and prevents scrolling */
        html, body {
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a; /* Dark background for the whole page */
        }

        /* This custom class helps constrain the layout on larger screens */
        .mobile-container {
            max-width: 480px; /* A common width for mobile design */
            height: 100vh;   /* Full viewport height */
            margin: 0 auto;   /* Center horizontally */
        }
        
        /* Custom class to apply the Anton font */
        .font-anton {
            font-family: 'Anton', sans-serif;
        }

        /* Custom class to apply the Inter font */
        .font-inter {
            font-family: 'Inter', sans-serif;
        }
        
        /* Utility to hide scrollbars for a cleaner look */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Styles for click-and-drag scrolling */
        .draggable {
            cursor: grab;
            user-select: none; /* Prevents text selection during drag */
        }
        .draggable.active {
            cursor: grabbing;
        }


        /* Styles for the moving emojis */
        .emoji {
            position: absolute;
            font-size: 2.5rem; /* Emojis are a bit larger for visibility */
            user-select: none; /* Prevents users from accidentally selecting them */
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer; /* Indicates the emoji is tappable */
            z-index: 20; /* Ensure emojis are above the dividers */
        }
        
        .special-item {
            position: absolute;
            font-size: 4rem;
            cursor: pointer;
            z-index: 25;
            top: 60%;
            transform: translate(-50%, -50%);
            transition: transform 0.2s ease;
        }
        .special-item:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .grid-square {
            position: relative; /* For positioning the indicator */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Slightly smaller font for equipped emojis */
            background-color: #4a5568; /* bg-gray-600 */
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.3s ease;
            isolation: isolate; /* Creates a new stacking context */
        }
        
        .travel-square {
            position: relative; /* For positioning the indicator */
            isolation: isolate; /* Creates a new stacking context */
        }

        .yellow-multiplier::after {
            content: '2x';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Anton', sans-serif;
            font-size: 3rem;
            color: white; /* Solid white text */
            pointer-events: none; /* Prevents it from interfering with clicks */
            z-index: -1; /* Places the '2x' behind the emoji content */
        }

        .grid-square:before {
            content: "";
            display: block;
            padding-top: 100%; /* This creates the square aspect ratio */
        }

        /* Style for route emojis to make them draggable */
        .route-emoji {
            cursor: grab;
        }
        
        /* Styles for Gamble Phase Slot Machine */
        .reel-container {
            display: flex;
            justify-content: center;
            gap: 0.75rem; /* Reduced gap */
            padding: 1rem;
        }
        .reel {
            width: 55px; /* Reduced width */
            height: 75px; /* Reduced height */
            background-color: #1f2937; /* bg-gray-800 */
            border: 2px solid #9ca3af; /* bg-gray-400 */
            border-radius: 0.5rem; /* rounded-lg */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Reduced font size */
            overflow: hidden;
            transition: all 0.2s ease-in-out; /* Smooth transition for glow */
        }
        .reel-win {
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 15px #fde047;
        }
        .spin-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #dc2626; /* bg-red-600 */
            border: 4px solid #ef4444; /* bg-red-500 */
            box-shadow: 0 5px #991b1b; /* shadow */
            transition: all 0.1s ease;
            cursor: pointer;
        }
        .spin-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px #991b1b;
        }
        .spin-button:disabled {
            background-color: #a1a1aa; /* bg-zinc-400 */
            box-shadow: 0 5px #71717a; /* bg-zinc-500 */
            cursor: not-allowed;
        }

        /* Resize 2x multiplier for summary screen */
        #market-summary .yellow-multiplier::after {
            font-size: 2.25rem;
        }
        #sell-summary .yellow-multiplier::after,
        #keep-summary .yellow-multiplier::after {
            font-size: 1.75rem;
        }


        /* Animation keyframes for moving down (fruits) */
        @keyframes move-down {
            from { top: -50px; } /* Start just above the screen */
            to { top: 100%; }   /* End just below the screen */
        }

        /* Animation keyframes for moving up (vegetables) */
        @keyframes move-up {
            from { bottom: -50px; } /* Start just below the screen */
            to { bottom: 100%; }    /* End just above the screen */
        }

        /* Styles for Choice Graph */
        .path-line {
            stroke: #6b7280; /* gray-500 */
            stroke-width: 4;
        }
        .node {
            fill: #581c87; /* dark purple */
            stroke: #9ca3af; /* gray-400 */
            stroke-width: 3;
            transition: fill 0.2s ease;
            cursor: pointer; /* Indicates nodes are clickable */
        }
        .node.gold {
            fill: #fde047; /* yellow-300 */
        }
        .node.pink {
            fill: #f472b6; /* pink-400 */
        }
        .node.black {
            fill: #1f2937; /* bg-gray-800 */
        }
        .node.start {
            fill: #10b981; /* emerald-500 */
        }
        .node.end {
            fill: #b91c1c; /* darker red, was red-500 (#ef4444) */
        }

        /* Combat Animations */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .shake-animation {
            animation: shake 0.3s ease-in-out;
        }

        @keyframes enemy-attack {
            50% { transform: scale(1.2) translateY(10px); }
            100% { transform: scale(1) translateY(0); }
        }
        .enemy-attack-animation {
            animation: enemy-attack 0.4s ease-out;
        }

        @keyframes stat-zoom {
            50% { transform: scale(1.25); }
            100% { transform: scale(1); }
        }
        .stat-zoom-animation {
            animation: stat-zoom 0.3s ease-in-out;
        }

    </style>
</head>
<body class="font-sans">

    <!-- Screen 1: Market -->
    <div id="market-screen" class="mobile-container flex flex-col h-screen bg-gray-800 text-white">

        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <!-- Countdown Timer -->
            <div id="countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section (Game Area) -->
        <main class="flex-grow bg-gray-700 relative">
            <!-- Grids for equipping emojis -->
            <div id="fruit-grid" class="absolute top-0 left-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>
            <div id="veg-grid" class="absolute top-0 right-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>

            <!-- The vertical divider lines -->
            <div class="absolute top-0 left-1/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-1/2 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-2/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            
            <!-- Conveyor belt containers -->
            <div id="fruit-conveyor" class="absolute top-0 left-1/3 h-full overflow-hidden" style="width: 16.6667%;"></div>
            <div id="vegetable-conveyor" class="absolute top-0 left-1/2 h-full overflow-hidden" style="width: 16.6667%;"></div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Market Text -->
            <div class="font-anton text-5xl tracking-widest">MARKET</div>
            <!-- Tappable Button -->
            <button id="skip-market-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>

    </div>

    <!-- Screen 2: Scavenge -->
    <div id="scavenge-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Countdown Timer for Scavenge Phase -->
            <div id="scavenge-countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-row overflow-hidden">
            <!-- Left Column -->
            <div id="sell-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-red-400 tracking-widest mb-2">SELL</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
            <!-- Middle Column (Swipable) -->
            <div id="scrollable-route" class="w-1/3 bg-gray-700 overflow-y-auto no-scrollbar draggable">
                <!-- Route content with numbers will be generated here -->
                <div id="route-content" class="flex flex-col items-center text-gray-400">
                </div>
            </div>
            <!-- Right Column -->
            <div id="keep-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-green-400 tracking-widest mb-2">KEEP</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Scavenge Text -->
            <div class="font-anton text-5xl tracking-widest">SCAVENGE</div>
            <!-- Tappable Button -->
            <button id="skip-scavenge-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>
    </div>

    <!-- Screen 3: Gamble -->
    <div id="gamble-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Gamble Timer -->
            <div id="gamble-countdown-timer" class="font-anton text-6xl tracking-wider">60</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-col items-center justify-center space-y-6">
            <!-- Gamble Mode Toggle -->
            <div id="gamble-mode-selector" class="flex items-center justify-center space-x-3 text-sm font-semibold">
                <span id="one-win-label" class="text-gray-400 transition-colors">ONE 2X WIN</span>
                <label for="gamble-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" value="" id="gamble-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-yellow-500 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-500"></div>
                </label>
                <span id="unlimited-wins-label" class="text-white transition-colors">UNLIMITED WINS</span>
            </div>
            
            <!-- Win Tracker -->
            <div id="win-tracker" class="font-anton text-4xl text-yellow-300 tracking-wider transition-all duration-300">$0</div>
            
            <!-- Slot Machine Reels -->
            <div id="reels-container" class="reel-container">
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
            </div>

            <!-- Spin Button -->
            <button id="spin-button" class="spin-button"></button>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Gamble Text -->
            <div class="font-anton text-5xl tracking-widest">GAMBLE</div>
            <!-- Tappable Button -->
            <button id="skip-gamble-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>
    </div>

    <!-- Screen 4: Results -->
    <div id="results-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">RESULTS</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 p-4 sm:p-6 flex flex-col justify-around">
            <!-- Market Summary -->
            <div>
                <h3 class="font-anton text-2xl tracking-wider text-indigo-300 mb-3 text-center">MARKET ITEMS</h3>
                <div class="flex items-center justify-center">
                    <div id="market-summary" class="grid grid-cols-4 gap-3">
                        <!-- Populated by JS -->
                    </div>
                    <div id="special-item-summary" class="ml-4 text-5xl">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- Scavenge & Gamble Summary Container -->
            <div>
                 <h3 class="font-anton text-2xl tracking-wider text-green-300 mb-3 text-center">SCAVENGE & GAMBLE</h3>
                <div class="flex items-start justify-between w-full">
                    <!-- Scavenge Summary -->
                    <div class="space-y-3 flex-1">
                         <!-- Sell Row -->
                        <div class="flex items-center">
                            <h4 class="font-anton text-lg text-red-400 mr-2 w-12 text-right">SELL</h4>
                            <div id="sell-summary" class="flex flex-row space-x-2">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        <!-- Keep Row -->
                        <div class="flex items-center mt-3">
                            <h4 class="font-anton text-lg text-green-400 mr-2 w-12 text-right">KEEP</h4>
                            <div id="keep-summary" class="flex flex-row space-x-2">
                               <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    <!-- Gamble Summary -->
                    <div class="text-center flex-shrink-0">
                        <h4 class="font-anton text-lg text-yellow-300">WINNINGS</h4>
                        <div id="gamble-summary" class="font-anton text-5xl text-yellow-300">
                            $0
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <div class="font-anton text-5xl tracking-widest"></div>
             <button id="next-button" class="bg-purple-600 hover:bg-purple-700 active:bg-purple-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Next
            </button>
        </footer>
    </div>

    <!-- Screen 5: Prepare -->
    <div id="prepare-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">PREPARE</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 p-4 grid grid-cols-2 grid-rows-2 gap-4">
            <!-- Food Window -->
            <div id="food-window" class="bg-gray-900 rounded-lg p-3 overflow-y-auto no-scrollbar">
                <h3 class="font-anton text-lg tracking-wider text-center mb-1">FOOD</h3>
                <div id="food-content">
                    <!-- JS will populate this -->
                </div>
            </div>
            <!-- Inventory Window -->
            <div id="inventory-window" class="bg-gray-900 rounded-lg p-3 overflow-y-auto no-scrollbar">
                <h3 class="font-anton text-lg tracking-wider text-center mb-1">INVENTORY</h3>
                <div id="inventory-content">
                    <!-- JS will populate this -->
                </div>
            </div>
            <!-- Equipment Window -->
            <div id="equipment-window" class="bg-gray-900 rounded-lg p-3">
                <h3 class="font-anton text-lg tracking-wider text-center mb-2">EQUIPMENT</h3>
                <div class="space-y-1">
                    <!-- Weapon Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Weapon</span>
                        <div id="weapon-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Armor Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Armor</span>
                        <div id="armor-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Ring Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Ring</span>
                        <div id="ring-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Accessory Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Accessory</span>
                        <div id="accessory-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                </div>
            </div>
            <!-- Stats Window -->
            <div id="stats-window" class="bg-gray-900 rounded-lg p-3 font-inter flex flex-col">
                <h3 class="font-anton text-lg tracking-wider text-center">STATS</h3>
                <div class="grid grid-cols-4 gap-x-1 gap-y-1 text-sm mt-1 flex-grow">
                    <span class="font-bold text-green-500 text-left">HP</span><span class="text-right" id="hp-stat-value">15</span>
                    <span class="font-bold text-purple-500 text-left">MP</span><span class="text-right" id="mp-stat-value">15</span>

                    <span class="font-bold text-blue-500 text-left">Armor</span><span class="text-right" id="armor-stat-value">3</span>
                    <span class="font-bold text-orange-500 text-left">Spirit</span><span class="text-right" id="spirit-stat-value">3</span>

                    <span class="font-bold text-red-500 text-left">Attack</span><span class="text-right" id="attack-stat-value">1</span>
                    <span class="font-bold text-teal-500 text-left">M. Atk</span><span class="text-right" id="magic-stat-value">2</span>

                    <span class="font-bold text-white text-left">Grace</span><span class="text-right" id="grace-stat-value">0</span>
                    <span class="font-bold text-gray-500 text-left">Fear</span><span class="text-right" id="fear-stat-value">0</span>
                </div>
                <div class="text-center mt-auto">
                    <span class="font-bold text-gray-300 text-sm">Materials</span>
                    <span class="text-sm" id="materials-stat-value">0</span>
                </div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center p-6">
            <button id="begin-button" class="bg-green-600 hover:bg-green-700 active:bg-green-800 text-white text-xl font-bold py-4 px-8 rounded-lg shadow-md transition-transform transform active:scale-95">
                BEGIN
            </button>
        </footer>
    </div>

    <!-- Screen 6: Choice Graph -->
    <div id="choice-screen" class="mobile-container hidden flex-col h-screen bg-gray-800 text-white">
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">JOURNEY</div>
        </header>
        <main class="flex-grow flex items-center justify-center p-4">
            <svg id="choice-graph" class="w-full h-full" viewBox="0 0 400 500">
                <!-- Paths -->
                <!-- Layer 0 -> 1 -->
                <line x1="200" y1="480" x2="100" y2="400" class="path-line"/>
                <line x1="200" y1="480" x2="300" y2="400" class="path-line"/>
                <!-- Layer 1 -> 2 -->
                <line x1="100" y1="400" x2="50" y2="319" class="path-line"/>
                <line x1="100" y1="400" x2="150" y2="319" class="path-line"/>
                <line x1="300" y1="400" x2="250" y2="319" class="path-line"/>
                <line x1="300" y1="400" x2="350" y2="319" class="path-line"/>
                <!-- Layer 2 -> 3 -->
                <line x1="50" y1="319" x2="50" y2="239" class="path-line"/>
                <line x1="150" y1="319" x2="125" y2="239" class="path-line"/>
                <line x1="150" y1="319" x2="175" y2="239" class="path-line"/>
                <line x1="250" y1="319" x2="225" y2="239" class="path-line"/>
                <line x1="250" y1="319" x2="275" y2="239" class="path-line"/>
                <line x1="350" y1="319" x2="350" y2="239" class="path-line"/>
                <!-- Layer 3 -> 4 -->
                <line x1="50" y1="239" x2="90" y2="158" class="path-line"/>
                <line x1="125" y1="239" x2="90" y2="158" class="path-line"/>
                <line x1="175" y1="239" x2="200" y2="158" class="path-line"/>
                <line x1="225" y1="239" x2="200" y2="158" class="path-line"/>
                <line x1="275" y1="239" x2="310" y2="158" class="path-line"/>
                <line x1="350" y1="239" x2="310" y2="158" class="path-line"/>
                <!-- Layer 4 -> End -->
                <line x1="90" y1="158" x2="150" y2="20" class="path-line"/>
                <line x1="200" y1="158" x2="150" y2="20" class="path-line"/>
                <line x1="200" y1="158" x2="250" y2="20" class="path-line"/>
                <line x1="310" y1="158" x2="250" y2="20" class="path-line"/>

                <!-- Nodes -->
                <circle cx="200" cy="480" r="12" class="node start" data-id="start"/>
                <!-- Tier 1 -->
                <circle cx="100" cy="400" r="12" class="node" data-id="t1_0"/>
                <circle cx="300" cy="400" r="12" class="node" data-id="t1_1"/>
                <!-- Tier 2 -->
                <circle cx="50" cy="319" r="12" class="node" data-id="t2_0"/>
                <circle cx="150" cy="319" r="12" class="node" data-id="t2_1"/>
                <circle cx="250" cy="319" r="12" class="node" data-id="t2_2"/>
                <circle cx="350" cy="319" r="12" class="node" data-id="t2_3"/>
                <!-- Tier 3 -->
                <circle cx="50" cy="239" r="12" class="node" data-id="t3_0"/>
                <circle cx="125" cy="239" r="12" class="node" data-id="t3_1"/>
                <circle cx="175" cy="239" r="12" class="node" data-id="t3_2"/>
                <circle cx="225" cy="239" r="12" class="node" data-id="t3_3"/>
                <circle cx="275" cy="239" r="12" class="node" data-id="t3_4"/>
                <circle cx="350" cy="239" r="12" class="node" data-id="t3_5"/>
                <!-- Tier 4 -->
                <circle cx="90" cy="158" r="12" class="node" data-id="t4_0"/>
                <circle cx="200" cy="158" r="12" class="node" data-id="t4_1"/>
                <circle cx="310" cy="158" r="12" class="node" data-id="t4_2"/>
                <!-- End -->
                <circle cx="150" cy="20" r="12" class="node end" data-id="end_0"/>
                <circle cx="250" cy="20" r="12" class="node end" data-id="end_1"/>
            </svg>
        </main>
    </div>


    <!-- Generic Equipment Selection Modal -->
    <div id="equipment-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-4 max-w-sm w-full">
            <h3 id="equipment-modal-title" class="font-anton text-2xl text-center mb-4">Choose Equipment</h3>
            <div id="equipment-options" class="grid grid-cols-4 gap-4">
                <!-- JS will populate this -->
            </div>
            <button id="close-equipment-modal" class="mt-4 w-full bg-red-600 text-white font-bold py-2 rounded-lg">Cancel</button>
        </div>
    </div>

    <!-- Screen 7: Combat -->
    <div id="combat-screen" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div id="combat-window" class="w-full max-w-md h-4/5 bg-gray-900 rounded-lg shadow-xl flex flex-col p-4 text-white">
            <!-- Top Info Section -->
            <div id="enemy-info-section" class="h-12 border-b border-gray-700 mb-4 flex justify-around items-center font-anton tracking-wider text-lg">
                <!-- Names will be populated by JS -->
            </div>
            <!-- Enemy Section -->
            <div id="enemy-display" class="flex-grow flex items-center justify-center space-x-16">
                <!-- Enemies will be populated by JS -->
            </div>
            <!-- Player Section -->
            <div id="player-display-wrapper" class="flex-grow flex flex-col items-center justify-center relative">
                <div id="player-display" class="text-8xl">
                    <!-- Player will be populated by JS -->
                </div>
                <div class="absolute bottom-0 w-full flex justify-between items-center px-4">
                    <div class="flex flex-col items-center">
                        <span class="font-inter text-xs font-bold mb-1">Magic Strike</span>
                        <label for="magic-strike-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="magic-strike-toggle" class="sr-only peer">
                            <div class="w-9 h-5 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                    <button id="combat-inventory-button" class="text-4xl active:scale-90 transition-transform">🎒</button>
                </div>
            </div>
            <!-- Bottom Info Section -->
            <div id="player-info-section" class="h-24 border-t border-gray-700 mt-4 p-2 flex flex-col justify-around">
                <!-- Top row for Armor, Attack, Spirit -->
                <div class="flex justify-around items-center text-lg font-bold">
                    <div id="combat-armor-stats" class="flex items-center">
                        <span>🛡️</span><span id="combat-armor" class="text-blue-500 ml-1"></span>
                    </div>
                    <div id="combat-attack-stats" class="flex items-center">
                        <span>⚔️</span><span id="combat-attack" class="text-red-500 ml-1"></span>
                    </div>
                    <div id="combat-spirit-stats" class="flex items-center">
                        <span>✨</span><span id="combat-spirit" class="text-orange-500 ml-1"></span>
                    </div>
                </div>
                <!-- Bottom row for HP and MP meters -->
                <div class="flex justify-between items-center space-x-2">
                    <!-- HP Meter -->
                    <div id="combat-health-stats" class="flex items-center w-1/2">
                        <span class="mr-1">❤️</span>
                        <div class="w-full bg-gray-600 rounded-full h-4 relative">
                            <div id="combat-hp-bar" class="bg-green-500 h-4 rounded-full transition-all duration-300"></div>
                            <span id="combat-hp-text" class="absolute inset-0 text-center text-xs font-bold leading-4"></span>
                        </div>
                    </div>
                    <!-- MP Meter -->
                    <div class="flex items-center w-1/2">
                        <span class="mr-1">💜</span>
                        <div class="w-full bg-gray-600 rounded-full h-4 relative">
                            <div id="combat-mp-bar" class="bg-purple-500 h-4 rounded-full transition-all duration-300"></div>
                            <span id="combat-mp-text" class="absolute inset-0 text-center text-xs font-bold leading-4"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Combat Inventory Modal -->
    <div id="combat-inventory-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-4 max-w-sm w-full">
            <h3 class="font-anton text-2xl text-center mb-4">Inventory</h3>
            <div id="combat-inventory-options" class="grid grid-cols-4 gap-4 max-h-64 overflow-y-auto no-scrollbar">
                <!-- JS will populate this -->
            </div>
            <button id="close-combat-inventory-modal" class="mt-4 w-full bg-red-600 text-white font-bold py-2 rounded-lg">Close</button>
        </div>
    </div>

    <!-- Reward Modal -->
    <div id="reward-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-6 max-w-sm w-full text-center">
            <h3 class="font-anton text-3xl text-yellow-300 mb-6">REWARD</h3>
            <div id="reward-display" class="font-anton text-5xl h-20 flex items-center justify-center bg-gray-900 rounded-lg text-white">
                <!-- JS will populate this -->
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Screen elements
            const marketScreen = document.getElementById('market-screen');
            const scavengeScreen = document.getElementById('scavenge-screen');
            const gambleScreen = document.getElementById('gamble-screen');
            const resultsScreen = document.getElementById('results-screen');
            const prepareScreen = document.getElementById('prepare-screen');
            const choiceScreen = document.getElementById('choice-screen');
            const combatScreen = document.getElementById('combat-screen');
            const combatWindow = document.getElementById('combat-window');
            
            // Market screen elements
            const fruitConveyor = document.getElementById('fruit-conveyor');
            const vegetableConveyor = document.getElementById('vegetable-conveyor');
            const fruitSquares = document.querySelectorAll('#fruit-grid .grid-square');
            const vegSquares = document.querySelectorAll('#veg-grid .grid-square');
            const allSquares = document.querySelectorAll('.grid-square');
            const countdownElement = document.getElementById('countdown-timer');

            // Scavenge screen elements
            const routeContent = document.getElementById('route-content');
            const scrollableRoute = document.getElementById('scrollable-route');
            const scavengeCountdownElement = document.getElementById('scavenge-countdown-timer');
            const sellSquares = document.querySelectorAll('#sell-column .travel-square');
            const keepSquares = document.querySelectorAll('#keep-column .travel-square');
            const allTravelSquares = document.querySelectorAll('.travel-square');

            // Gamble screen elements
            const gambleCountdownElement = document.getElementById('gamble-countdown-timer');
            const reels = document.querySelectorAll('#reels-container .reel');
            const spinButton = document.getElementById('spin-button');
            const winTracker = document.getElementById('win-tracker');
            const gambleToggle = document.getElementById('gamble-toggle');
            const oneWinLabel = document.getElementById('one-win-label');
            const unlimitedWinsLabel = document.getElementById('unlimited-wins-label');

            // Results screen elements
            const marketSummaryContainer = document.getElementById('market-summary');
            const sellSummaryContainer = document.getElementById('sell-summary');
            const keepSummaryContainer = document.getElementById('keep-summary');
            const gambleSummaryContainer = document.getElementById('gamble-summary');
            const specialItemSummaryContainer = document.getElementById('special-item-summary');
            const nextButton = document.getElementById('next-button');

            // Prepare screen elements
            const beginButton = document.getElementById('begin-button');

            // Skip buttons
            const skipMarketButton = document.getElementById('skip-market-button');
            const skipScavengeButton = document.getElementById('skip-scavenge-button');
            const skipGambleButton = document.getElementById('skip-gamble-button');


            const fruits = ['🍎', '🍊', '🍇', '🥥', '🍌'];
            const vegetables = ['🥦', '🌶️', '🥔', '🥕', '🌽'];
            const symbols = ['👛','💍','💎','👑','📿','⚖️','🪞','🖼️','⚱️','🦴','🧥','🪑','⛓️','🪚','📯','🎣','🔮','🃏','🪈','🗝️','🪓','🔨','🏹','🗡️'];
            const slotSymbols = ['🦓', '🫎', '🦄', '🦧', '🦎'];
            
            // Sell values for emojis
            const emojiSellValues = {
                '👛': 3, '💍': 3, '💎': 4, '👑': 4, '📿': 5, '⚖️': 5, '🪞': 6, '🖼️': 6, '⚱️': 10
            };
            const defaultSellValue = 2;
            
            // Combat state
            let combatState = {};

            function getEmojiSellValue(emoji) {
                return emojiSellValues[emoji] || defaultSellValue;
            }

            function getMultiplierFromColor(colorString) {
                switch (colorString) {
                    case 'rgb(253, 224, 71)': // yellow-300
                        return 2;
                    case 'rgb(59, 130, 246)':  // blue-500
                        return 1;
                    default:
                        return 1; // Default to 1x if color is unknown or not set
                }
            }

            // Game state variables
            let marketTimeLeft = 45;
            let scavengeTimeLeft = 45;
            let gambleTimeLeft = 60;
            let marketTimerInterval;
            let scavengeTimerInterval;
            let gambleTimerInterval;
            let fruitSpawnInterval;
            let vegSpawnInterval;
            let currentPhase = 'market';
            let isUnlimitedWinsMode = true; // Default to unlimited wins
            let totalWinnings = 0;
            let collectedMarketItems = [];
            let collectedSellItems = [];
            let collectedKeepItems = [];
            let hasWonGamble = false;
            let chosenSpecialItem = null;
            let marketFruitColorPattern = [];
            let marketVegColorPattern = [];
            let scavengeSellColorPattern = [];
            let scavengeKeepColorPattern = [];
            let marketCounts = {};
            let inventoryCounts = {};
            
            const baseStats = {
                hp: 15, mp: 15, armor: 3, spirit: 3, 
                attack: 1, magic: 2, grace: 0, fear: 0, materials: 0
            };
            
            let playerStats = { ...baseStats }; // Central state for player stats
            
            let equippedItems = {
                weapon: null,
                armor: null,
                ring: null,
                accessory: null
            };

            // Journey / Choice Graph state
            let graph = {};
            let unlockedNodes = new Set(['start']);
            let completedNodes = new Set();
            let currentNodeId = null;

            // Drag-and-drop state
            let isDraggingEmoji = false;
            let draggedClone = null;
            let originalDraggedElement = null;
            
            // Helper function to shuffle an array
            const shuffle = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            };

            /**
             * Populates the results screen with collected items and winnings.
             */
            function populateResultsScreen() {
                // Clear previous summary data
                marketSummaryContainer.innerHTML = '';
                sellSummaryContainer.innerHTML = '';
                keepSummaryContainer.innerHTML = '';
                specialItemSummaryContainer.innerHTML = '';

                // Helper to create small summary squares
                const createSmallSquare = (item, sizeClasses) => {
                    const square = document.createElement('div');
                    // Added 'isolate' to create a stacking context so z-index works as expected.
                    square.className = `${sizeClasses} isolate relative flex-shrink-0 flex items-center justify-center rounded-md`;
                    square.textContent = item.emoji;
                    
                    const bgColor = (item.color && item.color !== 'rgba(0, 0, 0, 0)') ? item.color : '#4a5568';
                    square.style.backgroundColor = bgColor;

                    // If the color is yellow, add the class for the 2x indicator
                    if (bgColor === 'rgb(253, 224, 71)') { // Corresponds to yellow-300
                        square.classList.add('yellow-multiplier');
                    }

                    return square;
                };

                // Populate market items
                collectedMarketItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-16 h-16 text-4xl');
                    marketSummaryContainer.appendChild(square);
                });

                // Populate chosen special item
                if (chosenSpecialItem) {
                    specialItemSummaryContainer.textContent = chosenSpecialItem;
                }

                // Populate sell items
                collectedSellItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    sellSummaryContainer.appendChild(square);
                });

                // Populate keep items
                collectedKeepItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    keepSummaryContainer.appendChild(square);
                });

                // Populate gamble winnings
                gambleSummaryContainer.textContent = `$${totalWinnings}`;
            }

            /**
             * Animates the selling of items on the results screen.
             */
            function startResultsPhaseAnimations() {
                setTimeout(() => {
                    const sellSummarySquares = sellSummaryContainer.children;
                    let displayedWinnings = totalWinnings;

                    // Animate each square
                    Array.from(sellSummarySquares).forEach((square, index) => {
                        setTimeout(() => {
                            // Find the corresponding item from our data array
                            const item = collectedSellItems[index];
                            if (!item) return;

                            const baseSellValue = getEmojiSellValue(item.emoji);
                            const multiplier = getMultiplierFromColor(item.color);
                            const finalSellValue = baseSellValue * multiplier;

                            // Animate the emoji fading out
                            square.classList.add('transition-all', 'duration-500', 'transform', 'scale-125', 'opacity-0');

                            // After the emoji fades out, update winnings and show the value
                            setTimeout(() => {
                                // Update displayed winnings total
                                displayedWinnings += finalSellValue;
                                gambleSummaryContainer.textContent = `$${displayedWinnings}`;
                                
                                // Add a little pop to the winnings text
                                gambleSummaryContainer.classList.add('transform', 'scale-110', 'transition-transform', 'duration-200');
                                setTimeout(() => {
                                    gambleSummaryContainer.classList.remove('transform', 'scale-110');
                                }, 200);

                                // Change the square to display the value and fade it back in, preserving its size
                                square.textContent = `+$${finalSellValue}`;
                                square.classList.remove('text-3xl', 'scale-125'); // Keep w-12 h-12 and other size classes
                                square.classList.add('font-anton', 'text-lg', 'text-yellow-300', 'opacity-100');
                                square.style.backgroundColor = 'transparent';


                                // After the last animation, update the master winnings variable
                                if (index === sellSummarySquares.length - 1) {
                                    totalWinnings = displayedWinnings;
                                    console.log("Final total after selling:", totalWinnings);
                                }
                            }, 500);

                        }, index * 1000); // Stagger the animation
                    });
                }, 2000); // Wait 2 seconds before starting
            }
            
            /**
             * Helper to render a section of items without square borders and more compactly.
             */
            const createItemHTML = (counts) => {
                if (Object.keys(counts).length === 0) return '<p class="text-gray-500 text-center text-sm">Empty</p>';
                // Using 5 columns to make it more compact
                let html = `<div class="grid grid-cols-5 gap-1">`;
                for (const [emoji, count] of Object.entries(counts)) {
                    html += `
                        <div class="flex flex-col items-center">
                            <div class="w-8 h-8 flex items-center justify-center text-xl">${emoji}</div>
                            <span class="text-xs font-bold">x${count}</span>
                        </div>
                    `;
                }
                html += `</div>`;
                return html;
            };

            /**
             * Updates the stats display based on player stats and equipped items.
             */
            function updateStatsUI() {
                let currentStats = { ...playerStats };

                // Add bonuses from equipment
                if (equippedItems.weapon) currentStats.attack += 1;
                if (equippedItems.armor === '🧥') currentStats.armor += 1;
                if (equippedItems.ring === '💍') currentStats.grace += 1;
                if (equippedItems.accessory === '👑') currentStats.fear -= 1;
                if (equippedItems.accessory === '📿') currentStats.grace += 1;

                // Update the DOM
                document.getElementById('hp-stat-value').textContent = currentStats.hp;
                document.getElementById('mp-stat-value').textContent = currentStats.mp;
                document.getElementById('armor-stat-value').textContent = currentStats.armor;
                document.getElementById('spirit-stat-value').textContent = currentStats.spirit;
                document.getElementById('attack-stat-value').textContent = currentStats.attack;
                document.getElementById('magic-stat-value').textContent = currentStats.magic;
                document.getElementById('grace-stat-value').textContent = currentStats.grace;
                document.getElementById('fear-stat-value').textContent = currentStats.fear;
                document.getElementById('materials-stat-value').textContent = currentStats.materials;
            }

            /**
             * Populates the inventory on the prepare screen.
             */
            function populatePrepareScreen() {
                const foodContent = document.getElementById('food-content');
                const inventoryContent = document.getElementById('inventory-content');
                foodContent.innerHTML = ''; 
                inventoryContent.innerHTML = '';

                // Helper to count item occurrences
                const countItems = (items) => {
                    const yellowColor = 'rgb(253, 224, 71)';
                    return items.reduce((acc, item) => {
                        if (item.emoji && item.emoji.trim() !== '') {
                            const quantity = item.color === yellowColor ? 2 : 1;
                            acc[item.emoji] = (acc[item.emoji] || 0) + quantity;
                        }
                        return acc;
                    }, {});
                };

                marketCounts = countItems(collectedMarketItems);
                inventoryCounts = countItems(collectedKeepItems); // Store globally for this screen
                
                // Add chosen special item (Bread or Wine) to the food list
                if (chosenSpecialItem) {
                    marketCounts[chosenSpecialItem] = (marketCounts[chosenSpecialItem] || 0) + 1;
                }

                // Populate Food window with market items
                foodContent.innerHTML = createItemHTML(marketCounts);

                // Populate Inventory window with kept items
                inventoryContent.innerHTML = createItemHTML(inventoryCounts);

                // Set up equipment listeners and initial stats
                setupEquipmentScreen();
                updateStatsUI();
            }

            const EQUIPMENT_MAP = {
                weapon: { emojis: ['🏹', '🗡️', '🦴', '🪈'], title: 'Choose a Weapon' },
                armor: { emojis: ['🧥'], title: 'Choose Armor' },
                ring: { emojis: ['💍'], title: 'Choose a Ring' },
                accessory: { emojis: ['👑', '📿'], title: 'Choose an Accessory' }
            };

            /**
             * Handles the logic of equipping an item.
             */
            function equipItem(itemEmoji, itemType) {
                const slot = document.getElementById(`${itemType}-slot`);
                const inventoryContent = document.getElementById('inventory-content');

                // If an item of the same type is already equipped, return it to the inventory count
                if (equippedItems[itemType]) {
                    inventoryCounts[equippedItems[itemType]] = (inventoryCounts[equippedItems[itemType]] || 0) + 1;
                }

                // Equip the new item
                equippedItems[itemType] = itemEmoji;
                inventoryCounts[itemEmoji]--; // Decrement from inventory
                if (inventoryCounts[itemEmoji] === 0) {
                    delete inventoryCounts[itemEmoji]; // Remove if count is zero
                }

                // Update the UI
                slot.textContent = equippedItems[itemType];
                inventoryContent.innerHTML = createItemHTML(inventoryCounts); // Refresh inventory display
                updateStatsUI();
            }

            /**
             * Sets up the equipment window and its interactions.
             */
            function setupEquipmentScreen() {
                const modal = document.getElementById('equipment-modal');
                const modalTitle = document.getElementById('equipment-modal-title');
                const optionsContainer = document.getElementById('equipment-options');
                const closeModalButton = document.getElementById('close-equipment-modal');

                const openEquipModal = (itemType) => {
                    const config = EQUIPMENT_MAP[itemType];
                    const availableItems = config.emojis.filter(emoji => inventoryCounts[emoji] > 0);

                    if (availableItems.length > 0) {
                        modalTitle.textContent = config.title;
                        optionsContainer.innerHTML = ''; // Clear old options
                        
                        availableItems.forEach(emoji => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'flex flex-col items-center cursor-pointer p-2 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors';
                            itemDiv.innerHTML = `
                                <div class="text-3xl">${emoji}</div>
                                <span class="text-xs font-bold mt-1">x${inventoryCounts[emoji]}</span>
                            `;
                            itemDiv.addEventListener('click', () => {
                                equipItem(emoji, itemType);
                                modal.classList.add('hidden');
                            });
                            optionsContainer.appendChild(itemDiv);
                        });
                        
                        modal.classList.remove('hidden');
                    } else {
                        console.log(`No items available for slot: ${itemType}`);
                    }
                };
                
                document.getElementById('weapon-slot').addEventListener('click', () => openEquipModal('weapon'));
                document.getElementById('armor-slot').addEventListener('click', () => openEquipModal('armor'));
                document.getElementById('ring-slot').addEventListener('click', () => openEquipModal('ring'));
                document.getElementById('accessory-slot').addEventListener('click', () => openEquipModal('accessory'));

                closeModalButton.addEventListener('click', () => {
                    modal.classList.add('hidden');
                });
            }


            /**
             * Ends the gamble phase.
             */
            function endGamblePhase() {
                if (currentPhase !== 'gamble') return;
                currentPhase = 'results'; 
                
                clearInterval(gambleTimerInterval);
                gambleTimeLeft = 0;
                gambleCountdownElement.textContent = "0";
                spinButton.disabled = true;
                gambleToggle.disabled = true;
                
                console.log("Gamble phase over. Gambling winnings: $" + totalWinnings);
                
                // Transition to Results Screen
                populateResultsScreen();
                gambleScreen.classList.add('hidden');
                resultsScreen.classList.remove('hidden');
                resultsScreen.classList.add('flex');
                
                // Start the animations for the results phase
                startResultsPhaseAnimations();
            }

            /**
             * Starts the countdown timer for the gamble phase.
             */
            function startGambleTimer() {
                gambleCountdownElement.textContent = gambleTimeLeft;
                gambleTimerInterval = setInterval(() => {
                    gambleTimeLeft--;
                    gambleCountdownElement.textContent = gambleTimeLeft;

                    if (gambleTimeLeft <= 0) {
                        clearInterval(gambleTimerInterval);
                        endGamblePhase();
                    }
                }, 1000);
            }

            /**
             * Reveals the colors of the scavenge squares sequentially.
             */
            function startScavengeColorReveal() {
                const yellowColor = 'rgb(253, 224, 71)'; // yellow-300

                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 3) {
                        // Reveal one sell square
                        const sellSquareToColor = sellSquares[revealIndex];
                        const sellColor = scavengeSellColorPattern[revealIndex];
                        sellSquareToColor.style.backgroundColor = sellColor;
                        if (sellColor === yellowColor) {
                            sellSquareToColor.classList.add('yellow-multiplier');
                        }
                        
                        // Reveal one keep square
                        const keepSquareToColor = keepSquares[revealIndex];
                        const keepColor = scavengeKeepColorPattern[revealIndex];
                        keepSquareToColor.style.backgroundColor = keepColor;
                        if (keepColor === yellowColor) {
                            keepSquareToColor.classList.add('yellow-multiplier');
                        }

                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 4000); // Reveal every 4 seconds
            }

             /**
             * Transitions the game from the Scavenge to the Gamble screen.
             */
            function endScavengePhase() {
                if (currentPhase !== 'scavenge') return;
                
                // Force apply all scavenge colors to ensure they are set before proceeding.
                const yellowColor = 'rgb(253, 224, 71)'; // yellow-300
                sellSquares.forEach((square, index) => {
                    const finalColor = scavengeSellColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                keepSquares.forEach((square, index) => {
                    const finalColor = scavengeKeepColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                
                // Store collected scavenge items, filtering out any empty slots
                collectedSellItems = Array.from(sellSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');

                collectedKeepItems = Array.from(keepSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');


                currentPhase = 'gamble';
                clearInterval(scavengeTimerInterval);

                scavengeScreen.classList.add('hidden');
                gambleScreen.classList.remove('hidden');
                gambleScreen.classList.add('flex');
                
                // Initialize reels with random symbols
                reels.forEach(reel => {
                    reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                });

                startGambleTimer();
            }
            
            /**
             * Checks if all 6 scavenge squares are filled.
             */
            function checkAllTravelSquaresFilled() {
                let filledCount = 0;
                allTravelSquares.forEach(square => {
                    if (square.innerText.trim() !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allTravelSquares.length) {
                    endScavengePhase();
                }
            }


            /**
             * Starts the countdown timer for the scavenge phase.
             */
            function startScavengeTimer() {
                scavengeCountdownElement.textContent = scavengeTimeLeft;
                scavengeTimerInterval = setInterval(() => {
                    scavengeTimeLeft--;
                    scavengeCountdownElement.textContent = scavengeTimeLeft;

                    if (scavengeTimeLeft <= 0) {
                        clearInterval(scavengeTimerInterval);
                        endScavengePhase(); // End scavenge phase when time runs out
                    }
                }, 1000);
            }

            /**
             * Transitions the game from the Market to the Scavenge screen.
             */
            function endMarketPhase() {
                if (currentPhase !== 'market') return;

                // Clear any remaining special items if player didn't choose
                const specialItems = document.querySelectorAll('.special-item');
                specialItems.forEach(item => item.remove());
                
                // Force apply all market colors to ensure they are set before proceeding.
                const yellowColor = 'rgb(253, 224, 71)';
                fruitSquares.forEach((square, index) => {
                    const finalColor = marketFruitColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                vegSquares.forEach((square, index) => {
                    const finalColor = marketVegColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                
                // Store collected market items
                collectedMarketItems = Array.from(allSquares).map(square => ({
                    emoji: square.textContent,
                    color: square.style.backgroundColor
                }));
                
                currentPhase = 'scavenge';

                // Stop all market-phase intervals
                clearInterval(marketTimerInterval);
                clearInterval(fruitSpawnInterval);
                clearInterval(vegSpawnInterval);

                // Clear any remaining emojis on the conveyor belts
                fruitConveyor.innerHTML = '';
                vegetableConveyor.innerHTML = '';
                
                // Hide market screen and show scavenge screen
                marketScreen.classList.add('hidden');
                scavengeScreen.classList.remove('hidden');
                scavengeScreen.classList.add('flex');
                
                // Generate and store the final color patterns for the scavenge squares
                const blueColor = 'rgb(59, 130, 246)'; // blue-500
                scavengeSellColorPattern = shuffle([blueColor, yellowColor, blueColor]);
                scavengeKeepColorPattern = shuffle([blueColor, yellowColor, blueColor]);

                // Start revealing scavenge square colors
                startScavengeColorReveal();

                // Start the scroll at the very bottom of the route
                scrollableRoute.scrollTop = scrollableRoute.scrollHeight;

                // Start the scavenge phase timer
                startScavengeTimer();
            }

             /**
             * Spawns the special choice emojis (wine and bread).
             */
            function spawnSpecialItems() {
                const gameArea = marketScreen.querySelector('main');
                
                const wineEmoji = document.createElement('div');
                wineEmoji.textContent = '🍷';
                wineEmoji.className = 'special-item';
                wineEmoji.style.left = '16.67%';

                const breadEmoji = document.createElement('div');
                breadEmoji.textContent = '🍞';
                breadEmoji.className = 'special-item';
                breadEmoji.style.left = '83.33%';

                const handleSpecialItemClick = (e) => {
                    chosenSpecialItem = e.target.textContent;
                    console.log(`Player chose: ${chosenSpecialItem}`);
                    wineEmoji.remove();
                    breadEmoji.remove();
                };

                wineEmoji.addEventListener('click', handleSpecialItemClick);
                breadEmoji.addEventListener('click', handleSpecialItemClick);

                gameArea.appendChild(wineEmoji);
                gameArea.appendChild(breadEmoji);
            }

            /**
             * Reveals the colors of the market squares sequentially.
             */
            function startColorReveal() {
                // Create shuffled lists of square indices to determine reveal order
                const fruitRevealOrder = shuffle([0, 1, 2, 3]);
                const vegRevealOrder = shuffle([0, 1, 2, 3]);
                const yellowColor = 'rgb(253, 224, 71)';

                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 4) {
                        // Reveal one fruit square based on the randomized reveal order
                        const fruitSquareIndex = fruitRevealOrder[revealIndex];
                        const fruitSquareToColor = fruitSquares[fruitSquareIndex];
                        const fruitColor = marketFruitColorPattern[fruitSquareIndex];
                        
                        fruitSquareToColor.style.backgroundColor = fruitColor;
                        if (fruitColor === yellowColor) {
                            fruitSquareToColor.classList.add('yellow-multiplier');
                        }

                        // Reveal one vegetable square based on the randomized reveal order
                        const vegSquareIndex = vegRevealOrder[revealIndex];
                        const vegSquareToColor = vegSquares[vegSquareIndex];
                        const vegColor = marketVegColorPattern[vegSquareIndex];
                        
                        vegSquareToColor.style.backgroundColor = vegColor;
                        if (vegColor === yellowColor) {
                            vegSquareToColor.classList.add('yellow-multiplier');
                        }
                        
                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 3000);
            }

            /**
             * Starts the countdown timer for the market phase.
             */
            function startMarketTimer() {
                const blue = 'rgb(59, 130, 246)';
                const yellow = 'rgb(253, 224, 71)';

                // Generate and store the final color patterns for the market squares
                marketFruitColorPattern = shuffle([yellow, blue, blue, blue]);
                marketVegColorPattern = shuffle([yellow, blue, blue, blue]);

                // Start the staggered color reveal for market squares
                startColorReveal();

                marketTimerInterval = setInterval(() => {
                    marketTimeLeft--;
                    countdownElement.textContent = marketTimeLeft;

                    if (marketTimeLeft === 30) {
                        spawnSpecialItems();
                    }

                    if (marketTimeLeft <= 0) {
                        countdownElement.textContent = "0";
                        endMarketPhase(); // End game when timer hits zero
                    }
                }, 1000);
            }

            /**
             * Checks if all grid squares are filled.
             */
            function checkAllSquaresFilled() {
                let filledCount = 0;
                allSquares.forEach(square => {
                    if (square.innerText !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allSquares.length) {
                    endMarketPhase(); // End game when all squares are full
                }
            }


            /**
             * Handles the logic when a conveyor belt emoji is clicked.
             */
            function handleEmojiClick(emojiElement, type) {
                const squares = (type === 'fruit') ? fruitSquares : vegSquares;
                const emojiText = emojiElement.innerText;

                let equipped = false;
                for (const square of squares) {
                    if (square.innerText === '') {
                        square.innerText = emojiText;
                        equipped = true;
                        break; 
                    }
                }

                if (equipped) {
                    emojiElement.remove();
                    checkAllSquaresFilled(); // Check if the game should end
                }
            }

            /**
             * Creates and animates a single emoji on a conveyor belt.
             */
            function createEmoji(type) {
                const emojiEl = document.createElement('span');
                emojiEl.classList.add('emoji');

                const conveyor = type === 'fruit' ? fruitConveyor : vegetableConveyor;
                const emojiArray = type === 'fruit' ? fruits : vegetables;
                
                emojiEl.innerText = emojiArray[Math.floor(Math.random() * emojiArray.length)];

                const duration = 10;
                emojiEl.style.animationDuration = `${duration}s`;
                emojiEl.style.animationTimingFunction = 'linear';
                
                if (type === 'fruit') {
                    emojiEl.style.animationName = 'move-down';
                } else {
                    emojiEl.style.animationName = 'move-up';
                }
                
                emojiEl.addEventListener('click', () => handleEmojiClick(emojiEl, type));
                emojiEl.addEventListener('animationend', () => emojiEl.remove());

                conveyor.appendChild(emojiEl);
            }
            
            /**
             * Starts spawning emojis on the conveyor belts.
             */
            function startSpawning() {
                const spawnInterval = 1200; 
                fruitSpawnInterval = setInterval(() => createEmoji('fruit'), spawnInterval);
                vegSpawnInterval = setInterval(() => createEmoji('vegetable'), spawnInterval + 200); // Offset spawn times slightly
            }

            /**
             * Populates the travel route with 101 draggable symbol emojis.
             */
            function populateRoute() {
                for (let i = 0; i <= 100; i++) {
                    const emojiEl = document.createElement('div');
                    const randomEmoji = symbols[Math.floor(Math.random() * symbols.length)];
                    emojiEl.textContent = randomEmoji;
                    
                    emojiEl.classList.add('text-3xl', 'py-10', 'route-emoji');
                    emojiEl.draggable = true;
                    emojiEl.id = `route-emoji-${i}`;
                    
                    routeContent.appendChild(emojiEl);
                }
            }

            /**
             * Calculates winnings from the slot machine spin.
             */
            function calculateWinnings(finalReels) {
                // Clear previous glows from all reels
                reels.forEach(r => r.classList.remove('reel-win'));

                let win = 0;
                let winningIndices = [];

                // Helper to apply glow effect
                const applyGlow = (indices) => {
                    indices.forEach(index => reels[index].classList.add('reel-win'));
                    setTimeout(() => {
                        indices.forEach(index => reels[index].classList.remove('reel-win'));
                    }, 1000); // Glow lasts for 1 second
                };

                // Check for wins, from longest to shortest to ensure highest payout
                if (finalReels.every(s => s === finalReels[0])) { // 5 of a kind
                    win = 50;
                    winningIndices = [0, 1, 2, 3, 4];
                } else if (finalReels.slice(0, 4).every(s => s === finalReels[0])) { // 4 of a kind from reel 1
                    win = 20;
                    winningIndices = [0, 1, 2, 3];
                } else if (finalReels.slice(1, 5).every(s => s === finalReels[1])) { // 4 of a kind from reel 2
                    win = 20;
                    winningIndices = [1, 2, 3, 4];
                } else if (finalReels.slice(0, 3).every(s => s === finalReels[0])) { // 3 of a kind from reel 1
                    win = 10;
                    winningIndices = [0, 1, 2];
                } else if (finalReels.slice(1, 4).every(s => s === finalReels[1])) { // 3 of a kind from reel 2
                    win = 10;
                    winningIndices = [1, 2, 3];
                } else if (finalReels.slice(2, 5).every(s => s === finalReels[2])) { // 3 of a kind from reel 3
                    win = 10;
                    winningIndices = [2, 3, 4];
                }

                if (win > 0) {
                    hasWonGamble = true;
                    
                    if (!isUnlimitedWinsMode) {
                        // ONE 2X WIN MODE
                        win = win * 2;
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);
                        
                        winTracker.classList.add('scale-125', 'text-green-400');
                        // End the phase immediately after the win animation
                        setTimeout(() => {
                            endGamblePhase(); 
                        }, 1100); 

                    } else {
                        // UNLIMITED WINS MODE (original logic)
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);

                        winTracker.classList.add('scale-125', 'text-green-400');
                        setTimeout(() => {
                            winTracker.classList.remove('scale-125', 'text-green-400');
                        }, 500);
                    }
                    return true; // Indicate a win occurred
                }

                return false; // No win
            }

            /**
             * Handles the spinning of the slot machine reels.
             */
            function spinReels() {
                spinButton.disabled = true;
                gambleToggle.disabled = true; // Lock the gamble mode on the first spin

                let finalReels = [];

                reels.forEach((reel, index) => {
                    const spinDuration = 1000 + (index * 300); // Staggered stop time
                    const spinInterval = 50; // How fast the symbols flash

                    const intervalId = setInterval(() => {
                        reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                    }, spinInterval);

                    setTimeout(() => {
                        clearInterval(intervalId);
                        const finalSymbol = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                        reel.textContent = finalSymbol;
                        finalReels[index] = finalSymbol;

                        // If this is the last reel to stop, calculate winnings and re-enable button
                        if (index === reels.length - 1) {
                            const hasWon = calculateWinnings(finalReels);
                            
                            // Do not re-enable button if game has ended or will end
                            if (isUnlimitedWinsMode || !hasWon) {
                                const reenableDelay = hasWon ? 1000 : 0; 
                                setTimeout(() => {
                                    if (gambleTimeLeft > 0) {
                                        spinButton.disabled = false;
                                    }
                                }, reenableDelay);
                            }
                        }
                    }, spinDuration);
                });
            }


            /**
             * Sets up both desktop and mobile drag-and-drop functionality.
             */
            function setupDragAndDrop() {
                // --- Desktop Drag Events ---
                routeContent.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        e.dataTransfer.setData('text/plain', e.target.textContent);
                        e.dataTransfer.setData('elementId', e.target.id);
                        e.dataTransfer.effectAllowed = 'move';
                        setTimeout(() => {
                            e.target.style.color = 'transparent';
                        }, 0);
                    }
                });

                routeContent.addEventListener('dragend', (e) => {
                    isDraggingEmoji = false;
                    if (e.target.classList.contains('route-emoji')) {
                        if (e.dataTransfer.dropEffect === 'none') {
                           e.target.style.color = '';
                        }
                    }
                });

                allTravelSquares.forEach(square => {
                    square.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (square.innerText.trim() === '') {
                             square.style.border = '2px dashed white';
                        }
                    });

                    square.addEventListener('dragleave', () => {
                        square.style.border = 'none';
                    });

                    square.addEventListener('drop', (e) => {
                        e.preventDefault();
                        square.style.border = 'none';
                        const emoji = e.dataTransfer.getData('text/plain');
                        if (square.innerText === '') {
                            square.innerText = emoji;
                            const elementId = e.dataTransfer.getData('elementId');
                            const draggedElement = document.getElementById(elementId);
                            if (draggedElement) {
                                draggedElement.draggable = false;
                                draggedElement.classList.remove('route-emoji');
                            }
                            checkAllTravelSquaresFilled();
                        }
                    });
                });

                // --- Mobile Touch Events ---
                function moveClone(x, y) {
                    if (draggedClone) {
                        draggedClone.style.left = `${x - draggedClone.offsetWidth / 2}px`;
                        draggedClone.style.top = `${y - draggedClone.offsetHeight / 2}px`;
                    }
                }

                routeContent.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        originalDraggedElement = e.target;
                        draggedClone = originalDraggedElement.cloneNode(true);
                        draggedClone.style.position = 'absolute';
                        draggedClone.style.zIndex = '1000';
                        draggedClone.style.pointerEvents = 'none';
                        document.body.appendChild(draggedClone);
                        
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);
                        
                        originalDraggedElement.style.color = 'transparent';
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (draggedClone) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);

                        allTravelSquares.forEach(square => {
                            const rect = square.getBoundingClientRect();
                            if (touch.clientX > rect.left && touch.clientX < rect.right &&
                                touch.clientY > rect.top && touch.clientY < rect.bottom &&
                                square.innerText.trim() === '') {
                                square.style.border = '2px solid white';
                            } else {
                                square.style.border = 'none';
                            }
                        });
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (!draggedClone) return;

                    const touch = e.changedTouches[0];
                    let droppedSuccessfully = false;

                    for (const square of allTravelSquares) {
                        const rect = square.getBoundingClientRect();
                        if (touch.clientX > rect.left && touch.clientX < rect.right &&
                            touch.clientY > rect.top && touch.clientY < rect.bottom) {
                            
                            if (square.innerText === '') {
                                square.innerText = originalDraggedElement.innerText;
                                originalDraggedElement.draggable = false;
                                originalDraggedElement.classList.remove('route-emoji');
                                droppedSuccessfully = true;
                                checkAllTravelSquaresFilled();
                            }
                            break;
                        }
                    }

                    if (!droppedSuccessfully) {
                        originalDraggedElement.style.color = '';
                    }
                    
                    draggedClone.remove();
                    draggedClone = null;
                    originalDraggedElement = null;
                    isDraggingEmoji = false;
                    allTravelSquares.forEach(square => square.style.border = 'none');
                });
            }
            
            /**
             * Adds click-and-drag scrolling for desktop testing.
             */
            function setupDesktopScrolling() {
                let isDown = false;
                let startY;
                let scrollTop;

                scrollableRoute.addEventListener('mousedown', (e) => {
                    if (isDraggingEmoji || e.target.classList.contains('route-emoji')) return;

                    isDown = true;
                    scrollableRoute.classList.add('active');
                    startY = e.pageY - scrollableRoute.offsetTop;
                    scrollTop = scrollableRoute.scrollTop;
                });

                scrollableRoute.addEventListener('mouseleave', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mouseup', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mousemove', (e) => {
                    if (!isDown || isDraggingEmoji) return;
                    e.preventDefault();
                    const y = e.pageY - scrollableRoute.offsetTop;
                    const walk = (y - startY) * 2;
                    scrollableRoute.scrollTop = scrollTop - walk;
                });
            }

            const sleep = ms => new Promise(res => setTimeout(res, ms));
            
            /**
             * Updates the displayed player attack value based on Magic Strike state.
             */
            function updateDisplayedAttack() {
                if (!combatState.player) return;
                const magicStrikeToggle = document.getElementById('magic-strike-toggle');
                const combatAttackEl = document.getElementById('combat-attack');
                
                let displayedAttack = combatState.player.attack;
                if (magicStrikeToggle.checked) {
                    displayedAttack += combatState.player.magicAtk;
                }
                combatAttackEl.textContent = displayedAttack;

                // Disable toggle if no magic resources are left
                if (combatState.player.spirit <= 0 && combatState.player.mp <= 0) {
                    magicStrikeToggle.disabled = true;
                } else {
                    magicStrikeToggle.disabled = false;
                }
            }
            
            /**
             * Handles the combat logic when an enemy is tapped.
             */
            async function handleAttack(targetEnemyState) {
                if (!targetEnemyState || targetEnemyState.hp <= 0 || combatState.isAnimating) return;

                combatState.isAnimating = true;

                const magicStrikeToggle = document.getElementById('magic-strike-toggle');
                let totalAttack = combatState.player.attack;
                
                // --- Magic Strike Logic ---
                if (magicStrikeToggle.checked) {
                    if (combatState.player.spirit > 0 || combatState.player.mp > 0) {
                        totalAttack += combatState.player.magicAtk;
                        const oldSpirit = combatState.player.spirit;

                        // Consume magic resource (spirit first, then MP)
                        if (combatState.player.spirit > 0) {
                            combatState.player.spirit--;
                            document.getElementById('combat-spirit').textContent = combatState.player.spirit;
                        } else {
                            combatState.player.mp--;
                             // MP Meter Update
                            const mpBar = document.getElementById('combat-mp-bar');
                            const mpText = document.getElementById('combat-mp-text');
                            mpText.textContent = `${combatState.player.mp}/${combatState.player.maxMp}`;
                            mpBar.style.width = `${Math.max(0, (combatState.player.mp / combatState.player.maxMp)) * 100}%`;
                        }

                        // Auto-toggle off if spirit is depleted
                        if (oldSpirit > 0 && combatState.player.spirit === 0) {
                            magicStrikeToggle.checked = false;
                            magicStrikeToggle.dispatchEvent(new Event('change')); // Update UI
                        }

                    } else {
                        // No resources left, turn it off
                        magicStrikeToggle.checked = false;
                        magicStrikeToggle.dispatchEvent(new Event('change')); // Update UI
                    }
                }
                // --- End Magic Strike Logic ---

                // 1. Player attack animation
                targetEnemyState.element.classList.add('shake-animation');
                await sleep(300);
                targetEnemyState.element.classList.remove('shake-animation');

                // 2. Player attack logic
                targetEnemyState.hp -= totalAttack;
                targetEnemyState.hpElement.textContent = Math.max(0, targetEnemyState.hp);

                if (targetEnemyState.hp <= 0) {
                    targetEnemyState.element.classList.add('transition-opacity', 'duration-500', 'opacity-0');
                    await sleep(500);
                    targetEnemyState.element.style.visibility = 'hidden';

                    const allEnemiesDefeated = combatState.enemies.every(e => e.hp <= 0);
                    if (allEnemiesDefeated && !combatState.isEnding) {
                        combatState.isEnding = true;
                        endCombat();
                    }
                    combatState.isAnimating = false;
                    return; // Dead enemy doesn't retaliate
                }

                // 3. Enemy retaliation animation
                await sleep(200); // Pause before retaliation
                const armorStatsEl = document.getElementById('combat-armor-stats');
                const healthStatsEl = document.getElementById('combat-health-stats');
                targetEnemyState.element.classList.add('enemy-attack-animation');

                const enemyAttack = targetEnemyState.attack;
                const damageToArmor = Math.min(combatState.player.armor, enemyAttack);
                const remainingDamage = enemyAttack - damageToArmor;

                if (damageToArmor > 0 && remainingDamage > 0) {
                    // Both are hit
                    if(armorStatsEl) armorStatsEl.classList.add('stat-zoom-animation');
                    if(healthStatsEl) healthStatsEl.classList.add('stat-zoom-animation');
                } else if (damageToArmor > 0) {
                    // Only armor is hit
                    if(armorStatsEl) armorStatsEl.classList.add('stat-zoom-animation');
                } else if (remainingDamage > 0) {
                    // Only HP is hit
                    if(healthStatsEl) healthStatsEl.classList.add('stat-zoom-animation');
                }


                // 4. Enemy retaliation logic
                combatState.player.armor -= damageToArmor;
                combatState.player.hp -= remainingDamage;

                // Update UI
                document.getElementById('combat-armor').textContent = combatState.player.armor;
                // HP Meter Update
                const hpBar = document.getElementById('combat-hp-bar');
                const hpText = document.getElementById('combat-hp-text');
                hpText.textContent = `${combatState.player.hp}/${combatState.player.maxHp}`;
                hpBar.style.width = `${Math.max(0, (combatState.player.hp / combatState.player.maxHp)) * 100}%`;


                await sleep(400); // Wait for animation to finish
                targetEnemyState.element.classList.remove('enemy-attack-animation');
                if (armorStatsEl) armorStatsEl.classList.remove('stat-zoom-animation');
                if (healthStatsEl) healthStatsEl.classList.remove('stat-zoom-animation');

                if (combatState.player.hp <= 0) {
                    console.log("Player has been defeated!");
                    if (!combatState.isEnding) {
                        combatState.isEnding = true;
                        endCombat();
                    }
                }
                
                combatState.isAnimating = false;
            }
            
            /**
             * Places an X over a completed node on the SVG graph.
             */
            function markNodeAsCompleted(nodeId) {
                const svg = document.getElementById('choice-graph');
                const nodeElement = svg.querySelector(`.node[data-id="${nodeId}"]`);
                if (!nodeElement) return;

                const cx = nodeElement.getAttribute('cx');
                const cy = nodeElement.getAttribute('cy');

                const xMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xMarker.setAttribute('x', cx);
                xMarker.setAttribute('y', cy);
                xMarker.setAttribute('font-size', '24');
                xMarker.setAttribute('fill', 'red');
                xMarker.setAttribute('text-anchor', 'middle');
                xMarker.setAttribute('dominant-baseline', 'central');
                xMarker.setAttribute('pointer-events', 'none'); // Prevents it from blocking clicks on other nodes
                xMarker.textContent = '❌';

                svg.appendChild(xMarker);
            }

            /**
             * Ends the current combat encounter.
             */
            async function endCombat() {
                console.log("Combat ended.");
                const playerWon = combatState.player.hp > 0;

                // Persist stats back to the central playerStats object
                playerStats.hp = Math.max(0, combatState.player.hp);
                playerStats.mp = combatState.player.mp;
                playerStats.spirit = baseStats.spirit; // Replenish Spirit

                if (playerWon) {
                    completedNodes.add(currentNodeId);
                    markNodeAsCompleted(currentNodeId);
                    
                    // Unlock next nodes
                    const nextNodeIds = graph[currentNodeId] || [];
                    nextNodeIds.forEach(id => unlockedNodes.add(id));
                    
                    console.log("Unlocked nodes:", ...unlockedNodes);

                    await showRewardPopup();
                }
                
                updateStatsUI(); // Update the main stats display
                
                // Hide the combat screen
                combatScreen.classList.add('hidden');
                currentNodeId = null; // Clear current node
            }

            /**
             * Displays the reward pop-up after a successful battle.
             */
            async function showRewardPopup() {
                return new Promise(resolve => {
                    const rewardModal = document.getElementById('reward-modal');
                    const rewardDisplay = document.getElementById('reward-display');
                    const rewards = [
                        { text: '$2', type: 'money', value: 2 },
                        { text: 'Heal 1 HP', type: 'hp', value: 1 },
                        { text: 'Heal 1 MP', type: 'mp', value: 1 }
                    ];
                    
                    rewardModal.classList.remove('hidden');

                    let shuffleCount = 0;
                    const maxShuffles = 20; // ~2 seconds
                    const shuffleInterval = setInterval(() => {
                        const randomReward = rewards[Math.floor(Math.random() * rewards.length)];
                        rewardDisplay.textContent = randomReward.text;
                        shuffleCount++;
                        if (shuffleCount >= maxShuffles) {
                            clearInterval(shuffleInterval);
                            
                            // Select and display the final reward
                            const finalReward = rewards[Math.floor(Math.random() * rewards.length)];
                            rewardDisplay.textContent = finalReward.text;

                            // Apply the final reward
                            switch (finalReward.type) {
                                case 'money':
                                    totalWinnings += finalReward.value;
                                    break;
                                case 'hp':
                                    playerStats.hp = Math.min(playerStats.hp + finalReward.value, baseStats.hp);
                                    break;
                                case 'mp':
                                    playerStats.mp = Math.min(playerStats.mp + finalReward.value, baseStats.mp);
                                    break;
                            }
                            
                            // Animate the final reward and make it tappable
                            rewardDisplay.classList.add('cursor-pointer', 'scale-110', 'transition-transform');
                            const closeRewardHandler = () => {
                                rewardModal.classList.add('hidden');
                                rewardDisplay.classList.remove('cursor-pointer', 'scale-110', 'transition-transform');
                                rewardDisplay.removeEventListener('click', closeRewardHandler);
                                resolve(); // Resolve the promise to continue
                            };
                            rewardDisplay.addEventListener('click', closeRewardHandler);
                        }
                    }, 100);
                });
            }

            /**
             * Populates and displays the combat inventory modal.
             */
            function populateAndShowCombatInventory() {
                const modal = document.getElementById('combat-inventory-modal');
                const optionsContainer = document.getElementById('combat-inventory-options');
                optionsContainer.innerHTML = ''; // Clear old options

                // Combine food and other inventory items
                const allItems = { ...marketCounts, ...inventoryCounts };

                if (Object.keys(allItems).length === 0) {
                    optionsContainer.innerHTML = '<p class="text-gray-500 text-center col-span-4">No items available.</p>';
                } else {
                    for (const [emoji, count] of Object.entries(allItems)) {
                        if (count > 0) {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'flex flex-col items-center cursor-pointer p-2 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors';
                            itemDiv.innerHTML = `
                                <div class="text-3xl">${emoji}</div>
                                <span class="text-xs font-bold mt-1">x${count}</span>
                            `;
                            // Tappable, but no action yet as per instructions
                            itemDiv.addEventListener('click', () => {
                                console.log(`Tapped on ${emoji}`);
                                // Future implementation for using items in combat
                            });
                            optionsContainer.appendChild(itemDiv);
                        }
                    }
                }

                modal.classList.remove('hidden');
            }

            const enemyPool = [
                { name: 'DARK WOLF', emoji: '🐺', hp: 5, attack: 2 },
                { name: 'POISON FROG', emoji: '🐸', hp: 5, attack: 2 },
                { name: 'VENOM SNAKE', emoji: '🐍', hp: 5, attack: 2 },
                { name: 'CURSED RAT', emoji: '🐀', hp: 5, attack: 2 },
                { name: 'DARK CROW', emoji: '🐦‍⬛', hp: 5, attack: 2 },
                { name: 'BLOODSQUITO', emoji: '🦟', hp: 5, attack: 2 }
            ];

            /**
             * Opens the combat screen and populates it with enemies for the given node.
             */
            function startCombat(nodeElement) {
                const enemyDisplay = document.getElementById('enemy-display');
                const enemyInfoSection = document.getElementById('enemy-info-section');
                const playerDisplay = document.getElementById('player-display');
                const magicStrikeToggle = document.getElementById('magic-strike-toggle');

                // Clear previous combatants
                enemyDisplay.innerHTML = '';
                enemyInfoSection.innerHTML = '';
                playerDisplay.innerHTML = '';
                
                currentNodeId = nodeElement.dataset.id;
                let currentEnemies = [];
                const classList = nodeElement.classList;
                
                // Determine if a battle should happen
                const isBattleNode = classList.contains('start') || !(classList.contains('end') || classList.contains('gold') || classList.contains('pink') || classList.contains('black'));

                if (isBattleNode) {
                    // Start node has a fixed encounter for now, others are random
                    if (classList.contains('start')) {
                         currentEnemies = [
                            { ...enemyPool[0], id: 0 }, // Wolf
                            { ...enemyPool[1], id: 1 }  // Frog
                         ];
                    } else {
                        const enemy1 = { ...enemyPool[Math.floor(Math.random() * enemyPool.length)], id: 0 };
                        const enemy2 = { ...enemyPool[Math.floor(Math.random() * enemyPool.length)], id: 1 };
                        currentEnemies = [enemy1, enemy2];
                    }
                } else {
                    console.log("No combat for special node:", currentNodeId);
                    currentNodeId = null; // Clear current node as no action is taken
                    return;
                }

                // Calculate current stats with equipment bonuses for this combat instance
                let currentCombatStats = { ...playerStats };
                if (equippedItems.weapon) currentCombatStats.attack += 1;
                if (equippedItems.armor === '🧥') currentCombatStats.armor += 1;
                if (equippedItems.ring === '💍') currentCombatStats.grace += 1;
                if (equippedItems.accessory === '👑') currentCombatStats.fear -= 1;
                if (equippedItems.accessory === '📿') currentCombatStats.grace += 1;
                
                // Initialize combat state
                combatState = {
                    isAnimating: false,
                    isEnding: false, // Flag to prevent multiple endCombat calls
                    player: {
                        hp: currentCombatStats.hp,
                        maxHp: playerStats.hp,
                        mp: currentCombatStats.mp,
                        maxMp: playerStats.mp,
                        armor: currentCombatStats.armor,
                        spirit: currentCombatStats.spirit,
                        attack: currentCombatStats.attack,
                        magicAtk: currentCombatStats.magic
                    },
                    enemies: []
                };

                // Populate enemies and their info
                currentEnemies.forEach(enemyData => {
                    const enemyContainer = document.createElement('div');
                    enemyContainer.className = 'flex flex-col items-center cursor-pointer';
                    enemyContainer.innerHTML = `
                        <div class="flex justify-between w-full px-2 text-lg font-bold">
                            <span class="text-green-500">${enemyData.hp}</span>
                            <span class="text-red-500">${enemyData.attack}</span>
                        </div>
                        <div class="text-6xl">${enemyData.emoji}</div>
                    `;
                    enemyDisplay.appendChild(enemyContainer);
                    
                    const enemyState = {
                        ...enemyData,
                        element: enemyContainer,
                        hpElement: enemyContainer.querySelector('.text-green-500')
                    };
                    combatState.enemies.push(enemyState);
                    
                    enemyContainer.addEventListener('click', () => handleAttack(enemyState));

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = enemyData.name;
                    enemyInfoSection.appendChild(nameSpan);
                });

                // Populate player
                playerDisplay.textContent = '👤';

                // Set up Magic Strike toggle
                magicStrikeToggle.checked = true; // Default ON
                // Ensure we don't add multiple listeners if combat is re-entered
                magicStrikeToggle.removeEventListener('change', updateDisplayedAttack); 
                magicStrikeToggle.addEventListener('change', updateDisplayedAttack);

                // Populate player stats UI
                document.getElementById('combat-armor').textContent = combatState.player.armor;
                document.getElementById('combat-spirit').textContent = combatState.player.spirit;

                // HP Meter
                const hpBar = document.getElementById('combat-hp-bar');
                const hpText = document.getElementById('combat-hp-text');
                hpText.textContent = `${combatState.player.hp}/${combatState.player.maxHp}`;
                hpBar.style.width = `${(combatState.player.hp / combatState.player.maxHp) * 100}%`;

                // MP Meter
                const mpBar = document.getElementById('combat-mp-bar');
                const mpText = document.getElementById('combat-mp-text');
                mpText.textContent = `${combatState.player.mp}/${combatState.player.maxMp}`;
                mpBar.style.width = `${(combatState.player.mp / combatState.player.maxMp) * 100}%`;
                
                // Update the displayed attack value based on the initial toggle state
                updateDisplayedAttack();

                // Show the combat screen
                combatScreen.classList.remove('hidden');
            }

            /**
             * Sets up the event listener for the gamble mode toggle switch.
             */
            function setupGambleToggle() {
                const updateToggleUI = () => {
                    isUnlimitedWinsMode = gambleToggle.checked;
                    if (isUnlimitedWinsMode) {
                        // Style for "UNLIMITED WINS" (checked) - Indigo toggle
                        unlimitedWinsLabel.classList.remove('text-gray-400');
                        unlimitedWinsLabel.classList.add('text-white');
                        oneWinLabel.classList.add('text-gray-400');
                        oneWinLabel.classList.remove('text-yellow-300');
                    } else {
                        // Style for "ONE 2X WIN" (unchecked) - Yellow toggle
                        oneWinLabel.classList.remove('text-gray-400');
                        oneWinLabel.classList.add('text-yellow-300');
                        unlimitedWinsLabel.classList.add('text-gray-400');
                        unlimitedWinsLabel.classList.remove('text-white');
                    }
                };

                gambleToggle.addEventListener('change', updateToggleUI);
                
                // Initialize UI based on default state when the script loads
                updateToggleUI();
            }

            // Initialize the game
            spinButton.addEventListener('click', spinReels);
            nextButton.addEventListener('click', () => {
                resultsScreen.classList.add('hidden');
                prepareScreen.classList.remove('hidden');
                prepareScreen.classList.add('flex');
                populatePrepareScreen();
            });

            beginButton.addEventListener('click', () => {
                prepareScreen.classList.add('hidden');
                choiceScreen.classList.remove('hidden');
                choiceScreen.classList.add('flex');

                // Define the graph structure based on node data-id attributes
                graph = {
                    'start': ['t1_0', 't1_1'], 't1_0': ['t2_0', 't2_1'], 't1_1': ['t2_2', 't2_3'],
                    't2_0': ['t3_0'], 't2_1': ['t3_1', 't3_2'], 't2_2': ['t3_3', 't3_4'], 't2_3': ['t3_5'],
                    't3_0': ['t4_0'], 't3_1': ['t4_0'], 't3_2': ['t4_1'], 't3_3': ['t4_1'],
                    't3_4': ['t4_2'], 't3_5': ['t4_2'], 't4_0': ['end_0'], 't4_1': ['end_0', 'end_1'],
                    't4_2': ['end_1'], 'end_0': [], 'end_1': []
                };

                // Recursive function to find all paths from a start to an end node
                const findPathsRecursive = (graph, start, end, path = []) => {
                    path = path.concat(start);
                    if (start === end) return [path];
                    if (!graph[start]) return [];
                    let paths = [];
                    for (let node of graph[start]) {
                        if (!path.includes(node)) {
                            let newPaths = findPathsRecursive(graph, node, end, path);
                            paths.push(...newPaths);
                        }
                    }
                    return paths;
                };

                // Find all possible paths from the start to either end node
                const pathsToEnd0 = findPathsRecursive(graph, 'start', 'end_0');
                const pathsToEnd1 = findPathsRecursive(graph, 'start', 'end_1');
                const allPossiblePaths = [...pathsToEnd0, ...pathsToEnd1];
                
                // Shuffle the paths to randomize which ones get colored
                const shuffledPaths = shuffle(allPossiblePaths);
                const colors = ['gold', 'pink', 'black'];
                const selectedPaths = shuffledPaths.slice(0, 3);

                // Reset all nodes to their default state first
                const allNodes = document.querySelectorAll('#choice-graph .node');
                allNodes.forEach(node => {
                    node.classList.remove('gold', 'pink', 'black');
                });

                // To ensure we color unique nodes
                const coloredNodeIds = new Set();

                // Assign one unique colored node for each selected path
                selectedPaths.forEach((path, index) => {
                    const color = colors[index];
                    if (!color) return;

                    // Find nodes on this path that can be colored (not start/end and not already colored)
                    const availableNodes = path.filter(nodeId => 
                        !nodeId.startsWith('start') && !nodeId.startsWith('end_') && !coloredNodeIds.has(nodeId)
                    );

                    if (availableNodes.length > 0) {
                        // Pick a random available node from the path to color
                        const nodeToColorId = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                        const nodeElement = document.querySelector(`.node[data-id="${nodeToColorId}"]`);
                        
                        if (nodeElement) {
                            nodeElement.classList.add(color);
                            coloredNodeIds.add(nodeToColorId); // Mark this node as colored
                        }
                    }
                });

                // Node click event to start combat
                const allGraphNodes = document.querySelectorAll('#choice-graph .node');
                allGraphNodes.forEach(node => {
                    node.addEventListener('click', (e) => {
                        const nodeId = e.target.dataset.id;
                        if (unlockedNodes.has(nodeId) && !completedNodes.has(nodeId)) {
                             startCombat(e.target);
                        } else if (completedNodes.has(nodeId)) {
                            console.log(`Node ${nodeId} already completed.`);
                        } else {
                             console.log(`Node ${nodeId} is locked.`);
                        }
                    });
                });
            });
            
            // Listener to close the combat modal when clicking the background
            combatScreen.addEventListener('click', (e) => {
                 if (e.target === combatScreen) {
                    console.log("Fled from combat.");
                    combatScreen.classList.add('hidden');
                    if (combatState) {
                        combatState.isAnimating = false;
                        combatState.isEnding = false;
                    }
                    currentNodeId = null;
                }
            });

            // Add listeners for combat inventory
            document.getElementById('combat-inventory-button').addEventListener('click', populateAndShowCombatInventory);
            document.getElementById('close-combat-inventory-modal').addEventListener('click', () => {
                document.getElementById('combat-inventory-modal').classList.add('hidden');
            });

            // Add listeners for skip buttons
            skipMarketButton.addEventListener('click', endMarketPhase);
            skipScavengeButton.addEventListener('click', endScavengePhase);
            skipGambleButton.addEventListener('click', endGamblePhase);

            startMarketTimer();
            startSpawning();
            populateRoute();
            setupDesktopScrolling();
            setupDragAndDrop();
            setupGambleToggle();
        });
    </script>

</body>
</html>

