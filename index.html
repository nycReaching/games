<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Use a game-like font */
        body {
            font-family: 'Inter', sans-serif; /* A more modern, clean font */
            touch-action: manipulation; /* Prevents double-tap to zoom on buttons */
            -webkit-tap-highlight-color: transparent; /* Removes tap highlight on mobile */
            overflow: hidden; /* Prevent scrolling */
        }
        /* Custom styles for the game canvas */
        #game-canvas {
            /* New Gradient Background */
            background: radial-gradient(ellipse at center, #4a5568 0%, #1a202c 70%);
            border-radius: 0.5rem;
            display: block; /* Ensures it behaves as a block element */
            transform-origin: center center; /* Ensure animations scale from the center */
        }
        /* Style for the control buttons for a tactile feel */
        .control-btn {
            transition: transform 0.1s ease;
        }

        /* Animation class for button press */
        .animate-press {
            animation: press-animation 0.2s ease-out;
        }

        @keyframes press-animation {
            0% { transform: scale(1); filter: brightness(100%); }
            50% { transform: scale(0.85); filter: brightness(160%); }
            100% { transform: scale(1); filter: brightness(100%); }
        }
        
        /* Screen shake animation for player getting hit */
        .shake-hard { animation: shake-hard-animation 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake-hard-animation {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Health bar container flash on hit */
        .health-flash {
            animation: health-flash-animation 0.4s ease-out;
        }
        @keyframes health-flash-animation {
            0%, 100% { box-shadow: 0 0 0 0px rgba(239, 68, 68, 0); }
            50% { box-shadow: 0 0 20px 8px rgba(239, 68, 68, 0.7); }
        }

        /* CRT Filter Styles */
        .crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            pointer-events: none; z-index: 9999;
        }
        .crt-overlay::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 200%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0, rgba(0,0,0,0.3) 1.5px, rgba(0,0,0,0.1) 3px);
            animation: scanline 10s linear infinite;
        }
        @keyframes scanline { from { transform: translateY(0); } to { transform: translateY(-50%); } }
        .crt-overlay::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6));
            opacity: 0.7;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-full flex flex-col antialiased">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full h-full max-w-md mx-auto flex flex-col p-4">

        <!-- Header: Game Stats -->
        <header class="flex-shrink-0 flex w-full rounded-lg mb-4 overflow-hidden h-12 shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899]">
            <!-- Health Meter -->
            <div class="flex-1 bg-red-950 relative flex items-center justify-center">
                <div id="health-bar" class="bg-red-500 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ù§Ô∏è</span>
                </div>
            </div>

            <!-- Energy Meter -->
            <div class="flex-1 bg-yellow-900 relative flex items-center justify-center">
                <div id="energy-bar" class="bg-yellow-400 h-full absolute top-0 left-0"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ú®</span>
                </div>
            </div>

            <!-- Shield Meter -->
            <div class="flex-1 bg-blue-950 relative flex items-center justify-center">
                <div id="shield-bar" class="bg-sky-400 h-full absolute top-0 left-0"></div>
                <div class="relative z-10 flex items-center">
                    <span class="text-2xl" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">üõ°Ô∏è</span>
                </div>
            </div>
        </header>

        <!-- Equipment Slots -->
        <div id="equipment-bar" class="flex-shrink-0 my-4">
            <!-- Slots Container -->
            <div class="grid grid-cols-4 gap-3">
                <!-- Slot 1 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üó°Ô∏è</span></div>
                <!-- Slot 2 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üîÆ</span></div>
                <!-- Slot 3 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üçé</span></div>
                <!-- Slot 4 -->
                <div class="aspect-square bg-black rounded-lg shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899] flex items-center justify-center"><span class="text-4xl md:text-5xl">üçû</span></div>
            </div>
        </div>

        <!-- Game Canvas Area -->
        <main class="flex-grow flex items-center justify-center relative">
             <div id="canvas-wrapper" class="relative w-full h-full flex items-center justify-center">
                <canvas id="game-canvas"></canvas>
                <!-- Enemy Status Bars -->
                <div id="enemy-stats" class="absolute bottom-4 w-3/4 max-w-xs h-8 flex rounded-lg overflow-hidden shadow-lg border-2 border-gray-700 opacity-0 transition-opacity duration-300">
                    <!-- Enemy Health -->
                    <div class="flex-1 bg-red-950 relative flex items-center justify-center">
                        <div id="enemy-health-bar" class="bg-red-500 h-full absolute top-0 left-0 transition-all duration-300 ease-out"></div>
                        <div class="relative z-10 flex items-center text-lg" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ù§Ô∏è</div>
                    </div>
                    <!-- Enemy Special -->
                    <div class="flex-1 bg-yellow-900 relative flex items-center justify-center">
                        <div id="enemy-special-bar" class="bg-yellow-400 h-full absolute top-0 left-0"></div>
                         <div class="relative z-10 flex items-center text-lg" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.8);">‚ö°</div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Controls Area -->
        <footer class="flex-shrink-0 mt-4 flex justify-center items-center">
            <!-- Action Button -->
            <button id="action-btn-a" class="w-24 h-24 bg-purple-600 rounded-full flex items-center justify-center control-btn shadow-[0_0_0_1px_#FDE047,0_0_0_2px_#06B6D4,0_0_0_3px_#EC4899]"></button>
        </footer>

    </div>

    <!-- CRT Filter Overlay -->
    <div class="crt-overlay"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const main = document.querySelector('main');
            const gameContainer = document.getElementById('game-container');
            const healthBar = document.getElementById('health-bar');
            const actionButton = document.getElementById('action-btn-a');
            const enemyStats = document.getElementById('enemy-stats');
            const enemyHealthBar = document.getElementById('enemy-health-bar');
            const enemySpecialBar = document.getElementById('enemy-special-bar');

            // --- Game State ---
            let player = { health: 10, maxHealth: 10 };
            const enemies = ['üëπ', 'üëª', 'üíÄ', 'üëΩ', 'ü§ñ', 'üéÉ', 'ü§°', 'üòà', 'üê≤'];
            let currentEnemyIndex = 0;
            let enemy = null; 
            let gameOver = false;
            let gameWon = false;
            let isAnimating = false;

            // --- Helper Functions ---
            function triggerAnimation(element, className) {
                element.classList.remove(className);
                void element.offsetWidth; 
                element.classList.add(className);
                element.addEventListener('animationend', () => {
                    element.classList.remove(className);
                }, { once: true });
            }
            
            // --- Easing function for smooth animations ---
            function easeInCubic(t) { return t * t * t; }
            function easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            // --- UI Update ---
            function updateMeters() {
                const healthPercent = (player.health / player.maxHealth) * 100;
                healthBar.style.width = `${healthPercent}%`;
            }

            function updateEnemyMeters() {
                if (!enemy) {
                    enemyStats.classList.add('opacity-0');
                    return;
                }
                enemyStats.classList.remove('opacity-0');
                const healthPercent = (enemy.hp / enemy.maxHp) * 100;
                enemyHealthBar.style.width = `${healthPercent}%`;
                // For now special meter is full
                enemySpecialBar.style.width = '100%';
            }


            // --- Canvas Sizing ---
            function resizeCanvas() {
                const mainRect = document.getElementById('canvas-wrapper').getBoundingClientRect();
                const size = Math.min(mainRect.width, mainRect.height) * 0.9;
                canvas.width = size;
                canvas.height = size;
            }

            // --- Animation Controller ---
            function updateEnemyAnimation() {
                if (!enemy || !enemy.animation) return;

                const anim = enemy.animation;
                anim.frame++;
                const progress = Math.min(anim.frame / anim.duration, 1);

                if (anim.type === 'appear') {
                    const t = easeOutBack(progress);
                    enemy.scale = t;
                    enemy.opacity = progress;
                    enemy.rotation = (1 - t) * -90; 
                } else if (anim.type === 'die') {
                    const t = easeInCubic(progress);
                    enemy.scale = 1 + t * 1.5;
                    enemy.rotation = t * 720;
                    enemy.opacity = 1 - progress;
                } else if (anim.type === 'hit') {
                    const t = Math.sin(progress * Math.PI * 4); // Fast oscillation
                    enemy.xOffset = t * 10;
                } else if (anim.type === 'attack') {
                    // Lunge forward and back
                    const progressMid = Math.abs(progress - 0.5) * 2; // Goes from 1 -> 0 -> 1
                    const t = 1 - progressMid; // Goes from 0 -> 1 -> 0
                    enemy.yOffset = t * 30; // Move down and back up
                    enemy.scale = 1 + t * 0.2; // Scale up and back down
                }


                if (anim.frame >= anim.duration) {
                    // Reset properties after any animation
                    enemy.animation = null;
                    enemy.xOffset = 0;
                    enemy.yOffset = 0;
                    enemy.scale = 1;
                    if (anim.onComplete) anim.onComplete();
                }
            }
            
            // --- Game Drawing Loop ---
            function gameLoop() {
                updateEnemyAnimation(); // Update animation states first

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (gameOver) {
                    // ... game over text ...
                } else if (gameWon) {
                    // ... you win text ...
                } else if (enemy) {
                    ctx.save();
                    ctx.globalAlpha = enemy.opacity;
                    
                    // Apply transformations for animation
                    const centerX = canvas.width / 2 + enemy.xOffset;
                    const centerY = canvas.height / 2 + enemy.yOffset;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(enemy.rotation * Math.PI / 180);
                    ctx.scale(enemy.scale, enemy.scale);
                    
                    const enemyFontSize = canvas.width * 0.4;
                    ctx.font = `${enemyFontSize}px sans-serif`;
                    ctx.fillText(enemy.emoji, 0, 0);
                    ctx.restore();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            function createEnemy(index) {
                return {
                    hp: 3 + index, maxHp: 3 + index, emoji: enemies[index],
                    // Animation properties
                    scale: 0, rotation: 0, opacity: 0, xOffset: 0, yOffset: 0,
                    animation: null
                };
            }
            
            function playEnemyAnimation(type) {
                if (!enemy) return Promise.resolve();
                return new Promise(resolve => {
                    let duration = 1;
                    if (type === 'hit') duration = 18;      // 0.3s
                    else if (type === 'die') duration = 30; // 0.5s
                    else if (type === 'appear') duration = 24; // 0.4s
                    else if (type === 'attack') duration = 24; // 0.4s
                    
                    enemy.animation = { type, duration, frame: 0, onComplete: resolve };
                });
            }

            async function spawnNextEnemy() {
                currentEnemyIndex++;
                if (currentEnemyIndex >= enemies.length) {
                    gameWon = true;
                } else {
                    enemy = createEnemy(currentEnemyIndex);
                    updateEnemyMeters();
                    await playEnemyAnimation('appear');
                }
            }

            // --- Event Listener ---
            actionButton.addEventListener('click', async () => {
                if (isAnimating || gameOver || gameWon || !enemy) return;
                isAnimating = true;

                triggerAnimation(actionButton, 'animate-press');
                await playEnemyAnimation('hit');
                
                enemy.hp -= 1;
                updateEnemyMeters();
                
                if (enemy.hp <= 0) {
                    await playEnemyAnimation('die');
                    enemy = null;
                    updateEnemyMeters();
                    await new Promise(r => setTimeout(r, 200));
                    await spawnNextEnemy();
                } else {
                    await new Promise(r => setTimeout(r, 400));
                    if (gameOver) return;

                    // Enemy retaliates
                    playEnemyAnimation('attack'); // Play attack anim, no need to wait for it
                    triggerAnimation(gameContainer, 'shake-hard');
                    triggerAnimation(healthBar.parentElement.parentElement, 'health-flash');
                    player.health -= 1;
                    updateMeters();

                    if (player.health <= 0) {
                        player.health = 0;
                        updateMeters();
                        gameOver = true;
                    }
                }
                
                await new Promise(r => setTimeout(r, 400)); // Cooldown
                isAnimating = false;
            });

            // --- Initial Setup ---
            async function init() {
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();
                updateMeters();
                enemy = createEnemy(currentEnemyIndex);
                updateEnemyMeters();
                gameLoop(); // Start the loop
                await new Promise(r => setTimeout(r, 200)); // Small delay before first spawn
                await playEnemyAnimation('appear');
            }
            
            init();
        });
    </script>

</body>
</html>

