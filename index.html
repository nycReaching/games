<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Anton font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        /* Ensures the layout takes up the full screen height and prevents scrolling */
        html, body {
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a; /* Dark background for the whole page */
        }

        /* This custom class helps constrain the layout on larger screens */
        .mobile-container {
            max-width: 480px; /* A common width for mobile design */
            height: 100vh;   /* Full viewport height */
            margin: 0 auto;   /* Center horizontally */
        }
        
        /* Custom class to apply the Anton font */
        .font-anton {
            font-family: 'Anton', sans-serif;
        }
        
        /* Utility to hide scrollbars for a cleaner look */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Styles for click-and-drag scrolling */
        .draggable {
            cursor: grab;
            user-select: none; /* Prevents text selection during drag */
        }
        .draggable.active {
            cursor: grabbing;
        }


        /* Styles for the moving emojis */
        .emoji {
            position: absolute;
            font-size: 2.5rem; /* Emojis are a bit larger for visibility */
            user-select: none; /* Prevents users from accidentally selecting them */
            text-shadow: 0 0 5px rgba(0,0,0,0.5); /* Adds a subtle shadow for depth */
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer; /* Indicates the emoji is tappable */
            z-index: 20; /* Ensure emojis are above the dividers */
        }

        .grid-square {
            position: relative; /* For positioning the indicator */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Slightly smaller font for equipped emojis */
            background-color: #4a5568; /* bg-gray-600 */
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.3s ease;
        }
        
        .travel-square {
            position: relative; /* For positioning the indicator */
        }

        .yellow-multiplier::after {
            content: '2x';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Anton', sans-serif;
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.3); /* Transparent white */
            pointer-events: none; /* Prevents it from interfering with clicks */
            z-index: 1;
        }

        .grid-square:before {
            content: "";
            display: block;
            padding-top: 100%; /* This creates the square aspect ratio */
        }

        /* Style for route emojis to make them draggable */
        .route-emoji {
            cursor: grab;
        }
        
        /* Styles for Gamble Phase Slot Machine */
        .reel-container {
            display: flex;
            justify-content: center;
            gap: 0.75rem; /* Reduced gap */
            padding: 1rem;
        }
        .reel {
            width: 55px; /* Reduced width */
            height: 75px; /* Reduced height */
            background-color: #1f2937; /* bg-gray-800 */
            border: 2px solid #9ca3af; /* bg-gray-400 */
            border-radius: 0.5rem; /* rounded-lg */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Reduced font size */
            overflow: hidden;
            transition: all 0.2s ease-in-out; /* Smooth transition for glow */
        }
        .reel-win {
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 15px #fde047;
        }
        .spin-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #ef4444; /* bg-red-500 */
            border: 4px solid #f87171; /* bg-red-400 */
            box-shadow: 0 5px #b91c1c; /* dark red shadow */
            transition: all 0.1s ease;
            cursor: pointer;
        }
        .spin-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px #b91c1c; /* dark red shadow */
        }
        .spin-button:disabled {
            background-color: #a1a1aa; /* bg-zinc-400 */
            box-shadow: 0 5px #71717a; /* bg-zinc-500 */
            cursor: not-allowed;
        }
        
        /* New styles for the custom gamble toggle */
        .gamble-toggle-container {
            position: relative;
            width: 150px;
            height: 30px;
            background-color: #374151; /* bg-gray-700 */
            border: 2px solid #4b5563; /* border-gray-600 */
            border-radius: 15px;
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s ease;
        }
        .gamble-toggle-container.disabled {
             cursor: not-allowed;
             opacity: 0.6;
        }
        
        .gamble-toggle-thumb {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #9ca3af; /* bg-gray-400 */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 3px solid #374151;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .gamble-toggle-container.left .gamble-toggle-thumb {
            left: 20px; /* Position for left selection */
            background-color: #facc15; /* yellow-400 */
            border-color: #fde047; /* yellow-300 */
        }

        .gamble-toggle-container.right .gamble-toggle-thumb {
            left: calc(100% - 20px); /* Position for right selection */
            background-color: #3b82f6; /* blue-500 */
            border-color: #60a5fa; /* blue-400 */
        }

        /* Animation keyframes for moving down (fruits) */
        @keyframes move-down {
            from { top: -50px; } /* Start just above the screen */
            to { top: 100%; }   /* End just below the screen */
        }

        /* Animation keyframes for moving up (vegetables) */
        @keyframes move-up {
            from { bottom: -50px; } /* Start just below the screen */
            to { bottom: 100%; }    /* End just above the screen */
        }

    </style>
</head>
<body class="font-sans">

    <!-- Screen 1: Market -->
    <div id="market-screen" class="mobile-container flex flex-col h-screen bg-gray-800 text-white">

        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <!-- Countdown Timer -->
            <div id="countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section (Game Area) -->
        <main class="flex-grow bg-gray-700 relative">
            <!-- Grids for equipping emojis -->
            <div id="fruit-grid" class="absolute top-0 left-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>
            <div id="veg-grid" class="absolute top-0 right-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>

            <!-- The vertical divider lines -->
            <div class="absolute top-0 left-1/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-1/2 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-2/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            
            <!-- Conveyor belt containers -->
            <div id="fruit-conveyor" class="absolute top-0 left-1/3 h-full overflow-hidden" style="width: 16.6667%;"></div>
            <div id="vegetable-conveyor" class="absolute top-0 left-1/2 h-full overflow-hidden" style="width: 16.6667%;"></div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Market Text -->
            <div class="font-anton text-5xl tracking-widest">MARKET</div>
            <!-- Tappable Button -->
            <button class="bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Action
            </button>
        </footer>

    </div>

    <!-- Screen 2: Travel -->
    <div id="travel-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Countdown Timer for Travel Phase -->
            <div id="travel-countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-row overflow-hidden">
            <!-- Left Column -->
            <div id="sell-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-red-400 tracking-widest mb-2">SELL</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
            <!-- Middle Column (Swipable) -->
            <div id="scrollable-route" class="w-1/3 bg-gray-700 overflow-y-auto no-scrollbar draggable">
                <!-- Route content with numbers will be generated here -->
                <div id="route-content" class="flex flex-col items-center text-gray-400">
                </div>
            </div>
            <!-- Right Column -->
            <div id="keep-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-green-400 tracking-widest mb-2">KEEP</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Travel Text -->
            <div class="font-anton text-5xl tracking-widest">TRAVEL</div>
            <!-- Tappable Button -->
            <button class="bg-green-600 hover:bg-green-700 active:bg-green-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Action
            </button>
        </footer>
    </div>

    <!-- Screen 3: Gamble -->
    <div id="gamble-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Gamble Timer -->
            <div id="gamble-countdown-timer" class="font-anton text-6xl tracking-wider">60</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-col items-center justify-center space-y-6">
            <!-- NEW Gamble Mode Toggle -->
            <div id="gamble-mode-selector" class="flex items-center justify-center space-x-4 text-sm font-semibold w-full px-4">
                <span id="two-x-label" class="text-gray-400 transition-colors duration-300 w-24 text-center">2X WIN</span>
                <div id="gamble-toggle-container" class="gamble-toggle-container">
                    <div id="gamble-toggle-thumb" class="gamble-toggle-thumb"></div>
                </div>
                <span id="unlimited-label" class="text-gray-400 transition-colors duration-300 w-24 text-center">UNLIMITED</span>
            </div>
            
            <!-- Win Tracker -->
            <div id="win-tracker" class="font-anton text-4xl text-yellow-300 tracking-wider transition-all duration-300">$0</div>
            
            <!-- Slot Machine Reels -->
            <div id="reels-container" class="reel-container">
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
            </div>

            <!-- Spin Button -->
            <button id="spin-button" class="spin-button"></button>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Gamble Text -->
            <div class="font-anton text-5xl tracking-widest">GAMBLE</div>
            <!-- Tappable Button -->
            <button class="bg-red-600 hover:bg-red-700 active:bg-red-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Action
            </button>
        </footer>
    </div>

    <!-- Screen 4: Prepare -->
    <div id="prepare-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">RESULTS</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 p-4 sm:p-6 flex flex-col justify-around">
            <!-- Market Summary -->
            <div>
                <h3 class="font-anton text-2xl tracking-wider text-indigo-300 mb-3 text-center">MARKET ITEMS</h3>
                <div id="market-summary" class="grid grid-cols-4 gap-3 w-max mx-auto">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- Divider -->
            <div class="border-t-2 border-gray-600 my-2"></div>

            <!-- Travel & Gamble Summary Container -->
            <div>
                 <h3 class="font-anton text-2xl tracking-wider text-green-300 mb-3 text-center">TRAVEL & GAMBLE</h3>
                <div class="flex flex-col gap-4">
                    <!-- Travel Summary -->
                    <div class="space-y-3 bg-gray-900/50 p-3 rounded-lg">
                         <!-- Sell Row -->
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <h4 class="font-anton text-lg text-red-400 mr-3 w-12 text-right">SELL</h4>
                                <div id="sell-summary" class="flex flex-row space-x-2">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                            <div id="sell-calculation" class="font-anton text-xl text-yellow-300 text-right transition-opacity duration-300 min-w-[6rem]"></div>
                        </div>
                        <!-- Keep Row -->
                        <div class="flex items-center">
                            <h4 class="font-anton text-lg text-green-400 mr-3 w-12 text-right">KEEP</h4>
                            <div id="keep-summary" class="flex flex-row space-x-2">
                               <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    <!-- Gamble Summary -->
                    <div class="text-center bg-gray-900/50 p-3 rounded-lg">
                        <h4 class="font-anton text-lg text-yellow-300">WINNINGS</h4>
                        <div id="gamble-summary" class="font-anton text-5xl text-yellow-300">
                            $0
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <div class="font-anton text-5xl tracking-widest">PREPARE</div>
            <button class="bg-purple-600 hover:bg-purple-700 active:bg-purple-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Next
            </button>
        </footer>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Screen elements
            const marketScreen = document.getElementById('market-screen');
            const travelScreen = document.getElementById('travel-screen');
            const gambleScreen = document.getElementById('gamble-screen');
            const prepareScreen = document.getElementById('prepare-screen');
            
            // Market screen elements
            const fruitConveyor = document.getElementById('fruit-conveyor');
            const vegetableConveyor = document.getElementById('vegetable-conveyor');
            const fruitSquares = document.querySelectorAll('#fruit-grid .grid-square');
            const vegSquares = document.querySelectorAll('#veg-grid .grid-square');
            const allSquares = document.querySelectorAll('.grid-square');
            const countdownElement = document.getElementById('countdown-timer');

            // Travel screen elements
            const routeContent = document.getElementById('route-content');
            const scrollableRoute = document.getElementById('scrollable-route');
            const travelCountdownElement = document.getElementById('travel-countdown-timer');
            const sellSquares = document.querySelectorAll('#sell-column .travel-square');
            const keepSquares = document.querySelectorAll('#keep-column .travel-square');
            const allTravelSquares = document.querySelectorAll('.travel-square');

            // Gamble screen elements
            const gambleCountdownElement = document.getElementById('gamble-countdown-timer');
            const reels = document.querySelectorAll('#reels-container .reel');
            const spinButton = document.getElementById('spin-button');
            const winTracker = document.getElementById('win-tracker');
            const gambleToggleContainer = document.getElementById('gamble-toggle-container');
            const twoXLabel = document.getElementById('two-x-label');
            const unlimitedLabel = document.getElementById('unlimited-label');


            // Prepare screen elements
            const marketSummaryContainer = document.getElementById('market-summary');
            const sellSummaryContainer = document.getElementById('sell-summary');
            const keepSummaryContainer = document.getElementById('keep-summary');
            const gambleSummaryContainer = document.getElementById('gamble-summary');
            const sellCalculationContainer = document.getElementById('sell-calculation');


            const fruits = ['🍎', '🍊', '🍇', '🥥', '🍌'];
            const vegetables = ['🥦', '🌶️', '🥔', '🥕', '🌽'];
            const symbols = ['👛','💍','💎','👑','📿','⚖️','🪞','🖼️','⚱️','🦴','🧥','🪑','⛓️','🪚','📯','🎣','🔮','🃏','🪈','🗝️','🪓','🔨','🏹','🗡️'];
            const slotSymbols = ['🦓', '🫎', '🦄', '🦧', '🦎'];
            
            // Sell values for emojis
            const emojiSellValues = {
                '👛': 3, '💍': 3, '💎': 4, '👑': 4, '📿': 5, '⚖️': 5, '🪞': 6, '🖼️': 6, '⚱️': 10
            };
            const defaultSellValue = 2;

            function getEmojiSellValue(emoji) {
                return emojiSellValues[emoji] || defaultSellValue;
            }

            function getMultiplierFromColor(colorString) {
                switch (colorString) {
                    case 'rgb(253, 224, 71)': // yellow-300
                        return 2;
                    case 'rgb(59, 130, 246)':  // blue-500
                        return 1;
                    default:
                        return 1; // Default to 1x if color is unknown or not set
                }
            }

            // Game state variables
            let marketTimeLeft = 45;
            let travelTimeLeft = 45;
            let gambleTimeLeft = 60;
            let marketTimerInterval;
            let travelTimerInterval;
            let gambleTimerInterval;
            let fruitSpawnInterval;
            let vegSpawnInterval;
            let currentPhase = 'market';
            let gambleSelection = null; // Can be '2x', 'unlimited', or null
            let totalWinnings = 0;
            let collectedMarketItems = [];
            let collectedSellItems = [];
            let collectedKeepItems = [];
            let hasSpunGamble = false;


            // Drag-and-drop state
            let isDraggingEmoji = false;
            let draggedClone = null;
            let originalDraggedElement = null;
            
            // Helper function to shuffle an array
            const shuffle = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            };

            /**
             * Populates the prepare screen with collected items and winnings.
             */
            function populatePrepareScreen() {
                // Clear previous summary data
                marketSummaryContainer.innerHTML = '';
                sellSummaryContainer.innerHTML = '';
                keepSummaryContainer.innerHTML = '';

                // Helper to create small summary squares
                const createSmallSquare = (item, sizeClasses) => {
                    const square = document.createElement('div');
                    square.className = `${sizeClasses} flex items-center justify-center rounded-md`;
                    square.textContent = item.emoji;
                    // Use the captured color, or a default gray if empty/transparent
                    square.style.backgroundColor = (item.color && item.color !== 'rgba(0, 0, 0, 0)') ? item.color : '#4a5568';
                    return square;
                };

                // Populate market items
                collectedMarketItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-16 h-16 text-4xl');
                    marketSummaryContainer.appendChild(square);
                });

                // Populate sell items
                collectedSellItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    sellSummaryContainer.appendChild(square);
                });

                // Populate keep items
                collectedKeepItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    keepSummaryContainer.appendChild(square);
                });

                // Populate gamble winnings
                gambleSummaryContainer.textContent = `$${totalWinnings}`;
            }

            /**
             * Animates the selling of items on the prepare screen.
             */
            function startPreparePhaseAnimations() {
                setTimeout(() => {
                    const sellSummarySquares = sellSummaryContainer.children;
                    let displayedWinnings = totalWinnings;
                    sellCalculationContainer.textContent = ''; // Clear at the start


                    // Animate each square
                    Array.from(sellSummarySquares).forEach((square, index) => {
                        setTimeout(() => {
                            // Find the corresponding item from our data array
                            const item = collectedSellItems[index];
                            if (!item) return;

                            const baseSellValue = getEmojiSellValue(item.emoji);
                            const multiplier = getMultiplierFromColor(item.color);
                            const finalSellValue = baseSellValue * multiplier;

                            // Set calculation text
                            let calculationText = '';
                            if (multiplier > 1) {
                                calculationText = `${multiplier}x $${baseSellValue}`;
                            } else {
                                // For 1x, just show the base value for simplicity
                                calculationText = `$${baseSellValue}`;
                            }
                            sellCalculationContainer.textContent = calculationText;
                            sellCalculationContainer.classList.remove('opacity-0');


                            // Add animation classes for zoom and fade
                            square.classList.add('transition-all', 'duration-[1500ms]', 'transform', 'scale-150', 'opacity-0');

                            // Update displayed winnings
                            displayedWinnings += finalSellValue;
                            gambleSummaryContainer.textContent = `$${displayedWinnings}`;
                            
                            // Add a little pop to the winnings text
                            gambleSummaryContainer.classList.add('transform', 'scale-110', 'transition-transform', 'duration-200');
                            setTimeout(() => {
                                gambleSummaryContainer.classList.remove('transform', 'scale-110');
                            }, 200);

                            // After the last animation, update the master winnings variable
                            if (index === sellSummarySquares.length - 1) {
                                totalWinnings = displayedWinnings;
                                console.log("Final total after selling:", totalWinnings);
                                // Fade out the calculation text after the last item is done
                                setTimeout(() => {
                                    sellCalculationContainer.classList.add('opacity-0');
                                }, 1800);
                            }

                        }, index * 1800); // Stagger the animation
                    });
                }, 2000); // Wait 2 seconds before starting
            }

            /**
             * Ends the gamble phase.
             */
            function endGamblePhase() {
                if (currentPhase !== 'gamble') return;
                currentPhase = 'prepare'; 
                
                clearInterval(gambleTimerInterval);
                gambleTimeLeft = 0;
                gambleCountdownElement.textContent = "0";
                spinButton.disabled = true;
                gambleToggleContainer.classList.add('disabled');
                
                console.log("Gamble phase over. Gambling winnings: $" + totalWinnings);
                
                // Transition to Prepare Screen
                populatePrepareScreen();
                gambleScreen.classList.add('hidden');
                prepareScreen.classList.remove('hidden');
                prepareScreen.classList.add('flex');
                
                // Start the animations for the prepare phase
                startPreparePhaseAnimations();
            }

            /**
             * Starts the countdown timer for the gamble phase.
             */
            function startGambleTimer() {
                gambleCountdownElement.textContent = gambleTimeLeft;
                gambleTimerInterval = setInterval(() => {
                    gambleTimeLeft--;
                    gambleCountdownElement.textContent = gambleTimeLeft;

                    if (gambleTimeLeft <= 0) {
                        clearInterval(gambleTimerInterval);
                        endGamblePhase();
                    }
                }, 1000);
            }

            /**
             * Reveals the colors of the travel squares sequentially.
             */
            function startTravelColorReveal() {
                const blueClass = 'bg-blue-500';
                const yellowClass = 'bg-yellow-300';
                const grayClass = 'bg-gray-600';

                const sellPattern = shuffle([blueClass, yellowClass, blueClass]);
                const keepPattern = shuffle([blueClass, yellowClass, blueClass]);

                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 3) {
                        // Reveal one sell square
                        const sellSquareToColor = sellSquares[revealIndex];
                        const sellColorClass = sellPattern[revealIndex];
                        sellSquareToColor.classList.remove(grayClass);
                        sellSquareToColor.classList.add(sellColorClass);
                        if (sellColorClass === yellowClass) {
                            sellSquareToColor.classList.add('yellow-multiplier');
                        }
                        
                        // Reveal one keep square
                        const keepSquareToColor = keepSquares[revealIndex];
                        const keepColorClass = keepPattern[revealIndex];
                        keepSquareToColor.classList.remove(grayClass);
                        keepSquareToColor.classList.add(keepColorClass);
                        if (keepColorClass === yellowClass) {
                            keepSquareToColor.classList.add('yellow-multiplier');
                        }

                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 4000); // Reveal every 4 seconds
            }

             /**
             * Transitions the game from the Travel to the Gamble screen.
             */
            function endTravelPhase() {
                if (currentPhase !== 'travel') return;
                
                // Store collected travel items, filtering out any empty slots
                collectedSellItems = Array.from(sellSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');

                collectedKeepItems = Array.from(keepSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');


                currentPhase = 'gamble';
                clearInterval(travelTimerInterval);

                travelScreen.classList.add('hidden');
                gambleScreen.classList.remove('hidden');
                gambleScreen.classList.add('flex');
                
                // Initialize reels with random symbols
                reels.forEach(reel => {
                    reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                });
                
                spinButton.disabled = true; // Spin button is disabled until a choice is made

                startGambleTimer();
            }
            
            /**
             * Checks if all 6 travel squares are filled.
             */
            function checkAllTravelSquaresFilled() {
                let filledCount = 0;
                allTravelSquares.forEach(square => {
                    if (square.innerText.trim() !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allTravelSquares.length) {
                    endTravelPhase();
                }
            }


            /**
             * Starts the countdown timer for the travel phase.
             */
            function startTravelTimer() {
                travelCountdownElement.textContent = travelTimeLeft;
                travelTimerInterval = setInterval(() => {
                    travelTimeLeft--;
                    travelCountdownElement.textContent = travelTimeLeft;

                    if (travelTimeLeft <= 0) {
                        clearInterval(travelTimerInterval);
                        endTravelPhase(); // End travel phase when time runs out
                    }
                }, 1000);
            }

            /**
             * Transitions the game from the Market to the Travel screen.
             */
            function endMarketPhase() {
                if (currentPhase !== 'market') return;
                
                // Store collected market items
                collectedMarketItems = Array.from(allSquares).map(square => ({
                    emoji: square.textContent,
                    color: square.style.backgroundColor
                }));
                
                currentPhase = 'travel';

                // Stop all market-phase intervals
                clearInterval(marketTimerInterval);
                clearInterval(fruitSpawnInterval);
                clearInterval(vegSpawnInterval);

                // Clear any remaining emojis on the conveyor belts
                fruitConveyor.innerHTML = '';
                vegetableConveyor.innerHTML = '';
                
                // Hide market screen and show travel screen
                marketScreen.classList.add('hidden');
                travelScreen.classList.remove('hidden');
                travelScreen.classList.add('flex');

                // Start revealing travel square colors
                startTravelColorReveal();

                // Start the scroll at the very bottom of the route
                scrollableRoute.scrollTop = scrollableRoute.scrollHeight;

                // Start the travel phase timer
                startTravelTimer();
            }

            /**
             * Reveals the colors of the market squares sequentially.
             */
            function startColorReveal() {
                let uncoloredFruitSquares = Array.from(fruitSquares);
                let uncoloredVegSquares = Array.from(vegSquares);

                const blue = 'rgb(59, 130, 246)';
                const yellow = 'rgb(253, 224, 71)';

                const fruitColorPattern = shuffle([yellow, blue, blue, blue]);
                const vegColorPattern = shuffle([yellow, blue, blue, blue]);
                
                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 4) {
                        // Reveal one fruit square
                        if (uncoloredFruitSquares.length > 0) {
                            const randomFruitIndex = Math.floor(Math.random() * uncoloredFruitSquares.length);
                            const fruitSquareToColor = uncoloredFruitSquares.splice(randomFruitIndex, 1)[0];
                            const fruitColor = fruitColorPattern[revealIndex];
                            fruitSquareToColor.style.backgroundColor = fruitColor;
                            if (fruitColor === yellow) {
                                fruitSquareToColor.classList.add('yellow-multiplier');
                            }
                        }
                        // Reveal one vegetable square
                        if (uncoloredVegSquares.length > 0) {
                             const randomVegIndex = Math.floor(Math.random() * uncoloredVegSquares.length);
                             const vegSquareToColor = uncoloredVegSquares.splice(randomVegIndex, 1)[0];
                             const vegColor = vegColorPattern[revealIndex];
                             vegSquareToColor.style.backgroundColor = vegColor;
                             if (vegColor === yellow) {
                                 vegSquareToColor.classList.add('yellow-multiplier');
                             }
                        }
                        
                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 3000);
            }

            /**
             * Starts the countdown timer for the market phase.
             */
            function startMarketTimer() {
                // Start the staggered color reveal for market squares
                startColorReveal();

                marketTimerInterval = setInterval(() => {
                    marketTimeLeft--;
                    countdownElement.textContent = marketTimeLeft;

                    if (marketTimeLeft <= 0) {
                        countdownElement.textContent = "0";
                        endMarketPhase(); // End game when timer hits zero
                    }
                }, 1000);
            }

            /**
             * Checks if all grid squares are filled.
             */
            function checkAllSquaresFilled() {
                let filledCount = 0;
                allSquares.forEach(square => {
                    if (square.innerText !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allSquares.length) {
                    endMarketPhase(); // End game when all squares are full
                }
            }


            /**
             * Handles the logic when a conveyor belt emoji is clicked.
             */
            function handleEmojiClick(emojiElement, type) {
                const squares = (type === 'fruit') ? fruitSquares : vegSquares;
                const emojiText = emojiElement.innerText;

                let equipped = false;
                for (const square of squares) {
                    if (square.innerText === '') {
                        square.innerText = emojiText;
                        equipped = true;
                        break; 
                    }
                }

                if (equipped) {
                    emojiElement.remove();
                    checkAllSquaresFilled(); // Check if the game should end
                }
            }

            /**
             * Creates and animates a single emoji on a conveyor belt.
             */
            function createEmoji(type) {
                const emojiEl = document.createElement('span');
                emojiEl.classList.add('emoji');

                const conveyor = type === 'fruit' ? fruitConveyor : vegetableConveyor;
                const emojiArray = type === 'fruit' ? fruits : vegetables;
                
                emojiEl.innerText = emojiArray[Math.floor(Math.random() * emojiArray.length)];

                const duration = 10;
                emojiEl.style.animationDuration = `${duration}s`;
                emojiEl.style.animationTimingFunction = 'linear';
                
                if (type === 'fruit') {
                    emojiEl.style.animationName = 'move-down';
                } else {
                    emojiEl.style.animationName = 'move-up';
                }
                
                emojiEl.addEventListener('click', () => handleEmojiClick(emojiEl, type));
                emojiEl.addEventListener('animationend', () => emojiEl.remove());

                conveyor.appendChild(emojiEl);
            }
            
            /**
             * Starts spawning emojis on the conveyor belts.
             */
            function startSpawning() {
                const spawnInterval = 1200; 
                fruitSpawnInterval = setInterval(() => createEmoji('fruit'), spawnInterval);
                vegSpawnInterval = setInterval(() => createEmoji('vegetable'), spawnInterval + 200); // Offset spawn times slightly
            }

            /**
             * Populates the travel route with 101 draggable symbol emojis.
             */
            function populateRoute() {
                for (let i = 0; i <= 100; i++) {
                    const emojiEl = document.createElement('div');
                    const randomEmoji = symbols[Math.floor(Math.random() * symbols.length)];
                    emojiEl.textContent = randomEmoji;
                    
                    emojiEl.classList.add('text-3xl', 'py-10', 'route-emoji');
                    emojiEl.draggable = true;
                    emojiEl.id = `route-emoji-${i}`;
                    
                    routeContent.appendChild(emojiEl);
                }
            }

            /**
             * Calculates winnings from the slot machine spin.
             */
            function calculateWinnings(finalReels) {
                // Clear previous glows from all reels
                reels.forEach(r => r.classList.remove('reel-win'));

                let win = 0;
                let winningIndices = [];

                // Helper to apply glow effect
                const applyGlow = (indices) => {
                    indices.forEach(index => reels[index].classList.add('reel-win'));
                    setTimeout(() => {
                        indices.forEach(index => reels[index].classList.remove('reel-win'));
                    }, 1000); // Glow lasts for 1 second
                };

                // Check for wins, from longest to shortest to ensure highest payout
                if (finalReels.every(s => s === finalReels[0])) { // 5 of a kind
                    win = 50;
                    winningIndices = [0, 1, 2, 3, 4];
                } else if (finalReels.slice(0, 4).every(s => s === finalReels[0])) { // 4 of a kind from reel 1
                    win = 20;
                    winningIndices = [0, 1, 2, 3];
                } else if (finalReels.slice(1, 5).every(s => s === finalReels[1])) { // 4 of a kind from reel 2
                    win = 20;
                    winningIndices = [1, 2, 3, 4];
                } else if (finalReels.slice(0, 3).every(s => s === finalReels[0])) { // 3 of a kind from reel 1
                    win = 10;
                    winningIndices = [0, 1, 2];
                } else if (finalReels.slice(1, 4).every(s => s === finalReels[1])) { // 3 of a kind from reel 2
                    win = 10;
                    winningIndices = [1, 2, 3];
                } else if (finalReels.slice(2, 5).every(s => s === finalReels[2])) { // 3 of a kind from reel 3
                    win = 10;
                    winningIndices = [2, 3, 4];
                }

                if (win > 0) {
                    if (gambleSelection === '2x') {
                        // 2X WIN MODE
                        win = win * 2;
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);
                        
                        winTracker.classList.add('scale-125', 'text-green-400');
                        // End the phase immediately after the win animation
                        setTimeout(() => {
                            endGamblePhase(); 
                        }, 1100); 

                    } else if (gambleSelection === 'unlimited') {
                        // UNLIMITED WINS MODE
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);

                        winTracker.classList.add('scale-125', 'text-green-400');
                        setTimeout(() => {
                            winTracker.classList.remove('scale-125', 'text-green-400');
                        }, 500);
                    }
                    return true; // Indicate a win occurred
                }

                return false; // No win
            }

            /**
             * Handles the spinning of the slot machine reels.
             */
            function spinReels() {
                if (!gambleSelection) return; // Can't spin if no selection is made

                hasSpunGamble = true;
                spinButton.disabled = true;
                gambleToggleContainer.classList.add('disabled'); // Lock the toggle

                let finalReels = [];

                reels.forEach((reel, index) => {
                    const spinDuration = 1000 + (index * 300); // Staggered stop time
                    const spinInterval = 50; // How fast the symbols flash

                    const intervalId = setInterval(() => {
                        reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                    }, spinInterval);

                    setTimeout(() => {
                        clearInterval(intervalId);
                        const finalSymbol = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                        reel.textContent = finalSymbol;
                        finalReels[index] = finalSymbol;

                        // If this is the last reel to stop, calculate winnings and re-enable button
                        if (index === reels.length - 1) {
                            const hasWon = calculateWinnings(finalReels);
                            
                            // Re-enable the spin button if the game isn't over.
                            // In '2x' mode, the game ends on a win.
                            // In 'unlimited' mode, it continues.
                            if ((gambleSelection === 'unlimited') || (gambleSelection === '2x' && !hasWon)) {
                                const reenableDelay = (gambleSelection === 'unlimited' && hasWon) ? 1000 : 0; 
                                setTimeout(() => {
                                    if (gambleTimeLeft > 0) {
                                        spinButton.disabled = false;
                                    }
                                }, reenableDelay);
                            }
                        }
                    }, spinDuration);
                });
            }


            /**
             * Sets up both desktop and mobile drag-and-drop functionality.
             */
            function setupDragAndDrop() {
                // --- Desktop Drag Events ---
                routeContent.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        e.dataTransfer.setData('text/plain', e.target.textContent);
                        e.dataTransfer.setData('elementId', e.target.id);
                        e.dataTransfer.effectAllowed = 'move';
                        setTimeout(() => {
                            e.target.style.color = 'transparent';
                        }, 0);
                    }
                });

                routeContent.addEventListener('dragend', (e) => {
                    isDraggingEmoji = false;
                    if (e.target.classList.contains('route-emoji')) {
                        if (e.dataTransfer.dropEffect === 'none') {
                           e.target.style.color = '';
                        }
                    }
                });

                allTravelSquares.forEach(square => {
                    square.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (square.innerText.trim() === '') {
                             square.style.border = '2px dashed white';
                        }
                    });

                    square.addEventListener('dragleave', () => {
                        square.style.border = 'none';
                    });

                    square.addEventListener('drop', (e) => {
                        e.preventDefault();
                        square.style.border = 'none';
                        const emoji = e.dataTransfer.getData('text/plain');
                        if (square.innerText === '') {
                            square.innerText = emoji;
                            const elementId = e.dataTransfer.getData('elementId');
                            const draggedElement = document.getElementById(elementId);
                            if (draggedElement) {
                                draggedElement.draggable = false;
                                draggedElement.classList.remove('route-emoji');
                            }
                            checkAllTravelSquaresFilled();
                        }
                    });
                });

                // --- Mobile Touch Events ---
                function moveClone(x, y) {
                    if (draggedClone) {
                        draggedClone.style.left = `${x - draggedClone.offsetWidth / 2}px`;
                        draggedClone.style.top = `${y - draggedClone.offsetHeight / 2}px`;
                    }
                }

                routeContent.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        originalDraggedElement = e.target;
                        draggedClone = originalDraggedElement.cloneNode(true);
                        draggedClone.style.position = 'absolute';
                        draggedClone.style.zIndex = '1000';
                        draggedClone.style.pointerEvents = 'none';
                        document.body.appendChild(draggedClone);
                        
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);
                        
                        originalDraggedElement.style.color = 'transparent';
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (draggedClone) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);

                        allTravelSquares.forEach(square => {
                            const rect = square.getBoundingClientRect();
                            if (touch.clientX > rect.left && touch.clientX < rect.right &&
                                touch.clientY > rect.top && touch.clientY < rect.bottom &&
                                square.innerText.trim() === '') {
                                square.style.border = '2px solid white';
                            } else {
                                square.style.border = 'none';
                            }
                        });
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (!draggedClone) return;

                    const touch = e.changedTouches[0];
                    let droppedSuccessfully = false;

                    for (const square of allTravelSquares) {
                        const rect = square.getBoundingClientRect();
                        if (touch.clientX > rect.left && touch.clientX < rect.right &&
                            touch.clientY > rect.top && touch.clientY < rect.bottom) {
                            
                            if (square.innerText === '') {
                                square.innerText = originalDraggedElement.innerText;
                                originalDraggedElement.draggable = false;
                                originalDraggedElement.classList.remove('route-emoji');
                                droppedSuccessfully = true;
                                checkAllTravelSquaresFilled();
                            }
                            break;
                        }
                    }

                    if (!droppedSuccessfully) {
                        originalDraggedElement.style.color = '';
                    }
                    
                    draggedClone.remove();
                    draggedClone = null;
                    originalDraggedElement = null;
                    isDraggingEmoji = false;
                    allTravelSquares.forEach(square => square.style.border = 'none');
                });
            }
            
            /**
             * Adds click-and-drag scrolling for desktop testing.
             */
            function setupDesktopScrolling() {
                let isDown = false;
                let startY;
                let scrollTop;

                scrollableRoute.addEventListener('mousedown', (e) => {
                    if (isDraggingEmoji || e.target.classList.contains('route-emoji')) return;

                    isDown = true;
                    scrollableRoute.classList.add('active');
                    startY = e.pageY - scrollableRoute.offsetTop;
                    scrollTop = scrollableRoute.scrollTop;
                });

                scrollableRoute.addEventListener('mouseleave', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mouseup', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mousemove', (e) => {
                    if (!isDown || isDraggingEmoji) return;
                    e.preventDefault();
                    const y = e.pageY - scrollableRoute.offsetTop;
                    const walk = (y - startY) * 2;
                    scrollableRoute.scrollTop = scrollTop - walk;
                });
            }

            /**
             * Sets up the event listener for the new sliding gamble mode toggle.
             */
            function setupGambleToggle() {
                gambleToggleContainer.addEventListener('click', (e) => {
                    if (hasSpunGamble) return; // Don't allow changes after first spin

                    const rect = gambleToggleContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    
                    // Determine if click was on the left or right half
                    if (clickX < rect.width / 2) {
                        setGambleSelection('2x');
                    } else {
                        setGambleSelection('unlimited');
                    }
                });
            }
            
            /**
             * Sets the gamble selection state and updates the UI.
             * @param {'2x' | 'unlimited'} selection The chosen gamble mode.
             */
            function setGambleSelection(selection) {
                if (hasSpunGamble) return;
                
                gambleSelection = selection;
                
                // Update UI based on selection
                if (selection === '2x') {
                    gambleToggleContainer.classList.add('left');
                    gambleToggleContainer.classList.remove('right');
                    twoXLabel.classList.remove('text-gray-400');
                    twoXLabel.classList.add('text-yellow-300');
                    unlimitedLabel.classList.add('text-gray-400');
                    unlimitedLabel.classList.remove('text-blue-400');
                } else { // 'unlimited'
                    gambleToggleContainer.classList.add('right');
                    gambleToggleContainer.classList.remove('left');
                    unlimitedLabel.classList.remove('text-gray-400');
                    unlimitedLabel.classList.add('text-blue-400');
                    twoXLabel.classList.add('text-gray-400');
                    twoXLabel.classList.remove('text-yellow-300');
                }
                
                // Enable the spin button once a selection has been made
                if (spinButton.disabled) {
                    spinButton.disabled = false;
                }
            }


            // Initialize the game
            spinButton.addEventListener('click', spinReels);
            startMarketTimer();
            startSpawning();
            populateRoute();
            setupDesktopScrolling();
            setupDragAndDrop();
            setupGambleToggle();
        });
    </script>

</body>
</html>



