<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Ensures the layout takes up the full screen height and prevents scrolling */
        html, body {
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a; /* Dark background for the whole page */
        }

        /* This custom class helps constrain the layout on larger screens */
        .mobile-container {
            max-width: 480px; /* A common width for mobile design */
            height: 100vh;   /* Full viewport height */
            margin: 0 auto;   /* Center horizontally */
        }
        
        /* Custom class to apply the Anton font */
        .font-anton {
            font-family: 'Anton', sans-serif;
        }

        /* Custom class to apply the Inter font */
        .font-inter {
            font-family: 'Inter', sans-serif;
        }
        
        /* Utility to hide scrollbars for a cleaner look */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Styles for click-and-drag scrolling */
        .draggable {
            cursor: grab;
            user-select: none; /* Prevents text selection during drag */
        }
        .draggable.active {
            cursor: grabbing;
        }


        /* Styles for the moving emojis */
        .emoji {
            position: absolute;
            font-size: 2.5rem; /* Emojis are a bit larger for visibility */
            user-select: none; /* Prevents users from accidentally selecting them */
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer; /* Indicates the emoji is tappable */
            z-index: 20; /* Ensure emojis are above the dividers */
        }
        
        .special-item {
            position: absolute;
            font-size: 4rem;
            cursor: pointer;
            z-index: 25;
            top: 60%;
            transform: translate(-50%, -50%);
            transition: transform 0.2s ease;
        }
        .special-item:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .grid-square {
            position: relative; /* For positioning the indicator */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Slightly smaller font for equipped emojis */
            background-color: #4a5568; /* bg-gray-600 */
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.3s ease;
            isolation: isolate; /* Creates a new stacking context */
        }
        
        .travel-square {
            position: relative; /* For positioning the indicator */
            isolation: isolate; /* Creates a new stacking context */
        }

        .yellow-multiplier::after {
            content: '2x';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Anton', sans-serif;
            font-size: 3rem;
            color: white; /* Solid white text */
            pointer-events: none; /* Prevents it from interfering with clicks */
            z-index: -1; /* Places the '2x' behind the emoji content */
        }

        .grid-square:before {
            content: "";
            display: block;
            padding-top: 100%; /* This creates the square aspect ratio */
        }

        /* Style for route emojis to make them draggable */
        .route-emoji {
            cursor: grab;
        }
        
        /* Styles for Gamble Phase Slot Machine */
        .reel-container {
            display: flex;
            justify-content: center;
            gap: 0.75rem; /* Reduced gap */
            padding: 1rem;
        }
        .reel {
            width: 55px; /* Reduced width */
            height: 75px; /* Reduced height */
            background-color: #1f2937; /* bg-gray-800 */
            border: 2px solid #9ca3af; /* bg-gray-400 */
            border-radius: 0.5rem; /* rounded-lg */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.25rem; /* Reduced font size */
            overflow: hidden;
            transition: all 0.2s ease-in-out; /* Smooth transition for glow */
        }
        .reel-win {
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 15px #fde047;
        }
        .spin-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #dc2626; /* bg-red-600 */
            border: 4px solid #ef4444; /* bg-red-500 */
            box-shadow: 0 5px #991b1b; /* shadow */
            transition: all 0.1s ease;
            cursor: pointer;
        }
        .spin-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px #991b1b;
        }
        .spin-button:disabled {
            background-color: #a1a1aa; /* bg-zinc-400 */
            box-shadow: 0 5px #71717a; /* bg-zinc-500 */
            cursor: not-allowed;
        }

        /* Resize 2x multiplier for summary screen */
        #market-summary .yellow-multiplier::after {
            font-size: 2.25rem;
        }
        #sell-summary .yellow-multiplier::after,
        #keep-summary .yellow-multiplier::after {
            font-size: 1.75rem;
        }


        /* Animation keyframes for moving down (fruits) */
        @keyframes move-down {
            from { top: -50px; } /* Start just above the screen */
            to { top: 100%; }   /* End just below the screen */
        }

        /* Animation keyframes for moving up (vegetables) */
        @keyframes move-up {
            from { bottom: -50px; } /* Start just below the screen */
            to { bottom: 100%; }    /* End just above the screen */
        }

    </style>
</head>
<body class="font-sans">

    <!-- Screen 1: Market -->
    <div id="market-screen" class="mobile-container flex flex-col h-screen bg-gray-800 text-white">

        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <!-- Countdown Timer -->
            <div id="countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section (Game Area) -->
        <main class="flex-grow bg-gray-700 relative">
            <!-- Grids for equipping emojis -->
            <div id="fruit-grid" class="absolute top-0 left-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>
            <div id="veg-grid" class="absolute top-0 right-0 w-1/3 h-auto p-2 z-20">
                <div class="grid grid-cols-2 gap-2">
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                    <div class="grid-square"></div>
                </div>
            </div>

            <!-- The vertical divider lines -->
            <div class="absolute top-0 left-1/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-1/2 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            <div class="absolute top-0 left-2/3 w-px h-full bg-gray-500 transform -translate-x-1/2 z-10"></div>
            
            <!-- Conveyor belt containers -->
            <div id="fruit-conveyor" class="absolute top-0 left-1/3 h-full overflow-hidden" style="width: 16.6667%;"></div>
            <div id="vegetable-conveyor" class="absolute top-0 left-1/2 h-full overflow-hidden" style="width: 16.6667%;"></div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Market Text -->
            <div class="font-anton text-5xl tracking-widest">MARKET</div>
            <!-- Tappable Button -->
            <button id="skip-market-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>

    </div>

    <!-- Screen 2: Scavenge -->
    <div id="scavenge-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Countdown Timer for Scavenge Phase -->
            <div id="scavenge-countdown-timer" class="font-anton text-6xl tracking-wider">45</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-row overflow-hidden">
            <!-- Left Column -->
            <div id="sell-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-red-400 tracking-widest mb-2">SELL</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
            <!-- Middle Column (Swipable) -->
            <div id="scrollable-route" class="w-1/3 bg-gray-700 overflow-y-auto no-scrollbar draggable">
                <!-- Route content with numbers will be generated here -->
                <div id="route-content" class="flex flex-col items-center text-gray-400">
                </div>
            </div>
            <!-- Right Column -->
            <div id="keep-column" class="w-1/3 bg-gray-800 flex flex-col items-center justify-center p-4 space-y-4">
                <h2 class="font-anton text-4xl text-green-400 tracking-widest mb-2">KEEP</h2>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
                <div class="w-20 h-20 md:w-24 md:h-24 bg-gray-600 rounded-lg shadow-lg travel-square flex items-center justify-center text-4xl"></div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Scavenge Text -->
            <div class="font-anton text-5xl tracking-widest">SCAVENGE</div>
            <!-- Tappable Button -->
            <button id="skip-scavenge-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>
    </div>

    <!-- Screen 3: Gamble -->
    <div id="gamble-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
             <!-- Gamble Timer -->
            <div id="gamble-countdown-timer" class="font-anton text-6xl tracking-wider">60</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 flex flex-col items-center justify-center space-y-6">
            <!-- Gamble Mode Toggle -->
            <div id="gamble-mode-selector" class="flex items-center justify-center space-x-3 text-sm font-semibold">
                <span id="one-win-label" class="text-gray-400 transition-colors">ONE 2X WIN</span>
                <label for="gamble-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" value="" id="gamble-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-yellow-500 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-500"></div>
                </label>
                <span id="unlimited-wins-label" class="text-white transition-colors">UNLIMITED WINS</span>
            </div>
            
            <!-- Win Tracker -->
            <div id="win-tracker" class="font-anton text-4xl text-yellow-300 tracking-wider transition-all duration-300">$0</div>
            
            <!-- Slot Machine Reels -->
            <div id="reels-container" class="reel-container">
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
                <div class="reel"></div>
            </div>

            <!-- Spin Button -->
            <button id="spin-button" class="spin-button"></button>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <!-- Gamble Text -->
            <div class="font-anton text-5xl tracking-widest">GAMBLE</div>
            <!-- Tappable Button -->
            <button id="skip-gamble-button" class="bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Skip
            </button>
        </footer>
    </div>

    <!-- Screen 4: Results -->
    <div id="results-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">RESULTS</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 p-4 sm:p-6 flex flex-col justify-around">
            <!-- Market Summary -->
            <div>
                <h3 class="font-anton text-2xl tracking-wider text-indigo-300 mb-3 text-center">MARKET ITEMS</h3>
                <div class="flex items-center justify-center">
                    <div id="market-summary" class="grid grid-cols-4 gap-3">
                        <!-- Populated by JS -->
                    </div>
                    <div id="special-item-summary" class="ml-4 text-5xl">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- Scavenge & Gamble Summary Container -->
            <div>
                 <h3 class="font-anton text-2xl tracking-wider text-green-300 mb-3 text-center">SCAVENGE & GAMBLE</h3>
                <div class="flex items-start justify-between w-full">
                    <!-- Scavenge Summary -->
                    <div class="space-y-3 flex-1">
                         <!-- Sell Row -->
                        <div class="flex items-center">
                            <h4 class="font-anton text-lg text-red-400 mr-2 w-12 text-right">SELL</h4>
                            <div id="sell-summary" class="flex flex-row space-x-2">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        <!-- Keep Row -->
                        <div class="flex items-center mt-3">
                            <h4 class="font-anton text-lg text-green-400 mr-2 w-12 text-right">KEEP</h4>
                            <div id="keep-summary" class="flex flex-row space-x-2">
                               <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    <!-- Gamble Summary -->
                    <div class="text-center flex-shrink-0">
                        <h4 class="font-anton text-lg text-yellow-300">WINNINGS</h4>
                        <div id="gamble-summary" class="font-anton text-5xl text-yellow-300">
                            $0
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-between p-6">
            <div class="font-anton text-5xl tracking-widest"></div>
             <button id="next-button" class="bg-purple-600 hover:bg-purple-700 active:bg-purple-800 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-md transition-transform transform active:scale-95">
                Next
            </button>
        </footer>
    </div>

    <!-- Screen 5: Prepare -->
    <div id="prepare-screen" class="mobile-container flex-col h-screen bg-gray-800 text-white hidden">
        <!-- Top Section -->
        <header class="h-32 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center">
            <div class="font-anton text-6xl tracking-wider">PREPARE</div>
        </header>

        <!-- Middle Section -->
        <main class="flex-grow bg-gray-700 p-4 grid grid-cols-2 grid-rows-2 gap-4">
            <!-- Food Window -->
            <div id="food-window" class="bg-gray-900 rounded-lg p-3 overflow-y-auto no-scrollbar">
                <h3 class="font-anton text-lg tracking-wider text-center mb-1">FOOD</h3>
                <div id="food-content">
                    <!-- JS will populate this -->
                </div>
            </div>
            <!-- Inventory Window -->
            <div id="inventory-window" class="bg-gray-900 rounded-lg p-3 overflow-y-auto no-scrollbar">
                <h3 class="font-anton text-lg tracking-wider text-center mb-1">INVENTORY</h3>
                <div id="inventory-content">
                    <!-- JS will populate this -->
                </div>
            </div>
            <!-- Equipment Window -->
            <div id="equipment-window" class="bg-gray-900 rounded-lg p-3">
                <h3 class="font-anton text-lg tracking-wider text-center mb-2">EQUIPMENT</h3>
                <div class="space-y-1">
                    <!-- Weapon Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Weapon</span>
                        <div id="weapon-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Armor Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Armor</span>
                        <div id="armor-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Ring Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Ring</span>
                        <div id="ring-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                    <!-- Accessory Slot -->
                    <div class="flex items-center justify-between">
                        <span class="font-inter font-bold text-xs">Accessory</span>
                        <div id="accessory-slot" class="w-8 h-8 bg-gray-700 rounded-md flex items-center justify-center text-xl cursor-pointer"></div>
                    </div>
                </div>
            </div>
            <!-- Stats Window -->
            <div id="stats-window" class="bg-gray-900 rounded-lg p-3 font-inter flex flex-col">
                <h3 class="font-anton text-lg tracking-wider text-center">STATS</h3>
                <div class="grid grid-cols-4 gap-x-2 gap-y-1 text-sm mt-1 flex-grow">
                    <span class="font-bold text-green-500 text-left">HP</span><span class="text-right" id="hp-stat-value">15</span>
                    <span class="font-bold text-purple-500 text-left">MP</span><span class="text-right" id="mp-stat-value">15</span>

                    <span class="font-bold text-blue-500 text-left">Armor</span><span class="text-right" id="armor-stat-value">3</span>
                    <span class="font-bold text-orange-500 text-left">Spirit</span><span class="text-right" id="spirit-stat-value">3</span>

                    <span class="font-bold text-red-500 text-left">Attack</span><span class="text-right" id="attack-stat-value">1</span>
                    <span class="font-bold text-teal-500 text-left">Magic</span><span class="text-right" id="magic-stat-value">2</span>

                    <span class="font-bold text-white text-left">Grace</span><span class="text-right" id="grace-stat-value">0</span>
                    <span class="font-bold text-red-800 text-left">Fear</span><span class="text-right" id="fear-stat-value">0</span>
                </div>
                <div class="text-center mt-auto">
                    <span class="font-bold text-gray-300 text-sm">Materials</span>
                    <span class="text-sm" id="materials-stat-value">0</span>
                </div>
            </div>
        </main>

        <!-- Bottom Section -->
        <footer class="h-36 bg-gray-900 shadow-lg flex-shrink-0 flex items-center justify-center p-6">
            <button id="begin-button" class="bg-green-600 hover:bg-green-700 active:bg-green-800 text-white text-xl font-bold py-4 px-8 rounded-lg shadow-md transition-transform transform active:scale-95">
                BEGIN
            </button>
        </footer>
    </div>

    <!-- Generic Equipment Selection Modal -->
    <div id="equipment-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-4 max-w-sm w-full">
            <h3 id="equipment-modal-title" class="font-anton text-2xl text-center mb-4">Choose Equipment</h3>
            <div id="equipment-options" class="grid grid-cols-4 gap-4">
                <!-- JS will populate this -->
            </div>
            <button id="close-equipment-modal" class="mt-4 w-full bg-red-600 text-white font-bold py-2 rounded-lg">Cancel</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Screen elements
            const marketScreen = document.getElementById('market-screen');
            const scavengeScreen = document.getElementById('scavenge-screen');
            const gambleScreen = document.getElementById('gamble-screen');
            const resultsScreen = document.getElementById('results-screen');
            const prepareScreen = document.getElementById('prepare-screen');
            
            // Market screen elements
            const fruitConveyor = document.getElementById('fruit-conveyor');
            const vegetableConveyor = document.getElementById('vegetable-conveyor');
            const fruitSquares = document.querySelectorAll('#fruit-grid .grid-square');
            const vegSquares = document.querySelectorAll('#veg-grid .grid-square');
            const allSquares = document.querySelectorAll('.grid-square');
            const countdownElement = document.getElementById('countdown-timer');

            // Scavenge screen elements
            const routeContent = document.getElementById('route-content');
            const scrollableRoute = document.getElementById('scrollable-route');
            const scavengeCountdownElement = document.getElementById('scavenge-countdown-timer');
            const sellSquares = document.querySelectorAll('#sell-column .travel-square');
            const keepSquares = document.querySelectorAll('#keep-column .travel-square');
            const allTravelSquares = document.querySelectorAll('.travel-square');

            // Gamble screen elements
            const gambleCountdownElement = document.getElementById('gamble-countdown-timer');
            const reels = document.querySelectorAll('#reels-container .reel');
            const spinButton = document.getElementById('spin-button');
            const winTracker = document.getElementById('win-tracker');
            const gambleToggle = document.getElementById('gamble-toggle');
            const oneWinLabel = document.getElementById('one-win-label');
            const unlimitedWinsLabel = document.getElementById('unlimited-wins-label');

            // Results screen elements
            const marketSummaryContainer = document.getElementById('market-summary');
            const sellSummaryContainer = document.getElementById('sell-summary');
            const keepSummaryContainer = document.getElementById('keep-summary');
            const gambleSummaryContainer = document.getElementById('gamble-summary');
            const specialItemSummaryContainer = document.getElementById('special-item-summary');
            const nextButton = document.getElementById('next-button');

            // Skip buttons
            const skipMarketButton = document.getElementById('skip-market-button');
            const skipScavengeButton = document.getElementById('skip-scavenge-button');
            const skipGambleButton = document.getElementById('skip-gamble-button');


            const fruits = ['🍎', '🍊', '🍇', '🥥', '🍌'];
            const vegetables = ['🥦', '🌶️', '🥔', '🥕', '🌽'];
            const symbols = ['👛','💍','💎','👑','📿','⚖️','🪞','🖼️','⚱️','🦴','🧥','🪑','⛓️','🪚','📯','🎣','🔮','🃏','🪈','🗝️','🪓','🔨','🏹','🗡️'];
            const slotSymbols = ['🦓', '🫎', '🦄', '🦧', '🦎'];
            
            // Sell values for emojis
            const emojiSellValues = {
                '👛': 3, '💍': 3, '💎': 4, '👑': 4, '📿': 5, '⚖️': 5, '🪞': 6, '🖼️': 6, '⚱️': 10
            };
            const defaultSellValue = 2;

            function getEmojiSellValue(emoji) {
                return emojiSellValues[emoji] || defaultSellValue;
            }

            function getMultiplierFromColor(colorString) {
                switch (colorString) {
                    case 'rgb(253, 224, 71)': // yellow-300
                        return 2;
                    case 'rgb(59, 130, 246)':  // blue-500
                        return 1;
                    default:
                        return 1; // Default to 1x if color is unknown or not set
                }
            }

            // Game state variables
            let marketTimeLeft = 45;
            let scavengeTimeLeft = 45;
            let gambleTimeLeft = 60;
            let marketTimerInterval;
            let scavengeTimerInterval;
            let gambleTimerInterval;
            let fruitSpawnInterval;
            let vegSpawnInterval;
            let currentPhase = 'market';
            let isUnlimitedWinsMode = true; // Default to unlimited wins
            let totalWinnings = 0;
            let collectedMarketItems = [];
            let collectedSellItems = [];
            let collectedKeepItems = [];
            let hasWonGamble = false;
            let chosenSpecialItem = null;
            let marketFruitColorPattern = [];
            let marketVegColorPattern = [];
            let scavengeSellColorPattern = [];
            let scavengeKeepColorPattern = [];
            let inventoryCounts = {};
            
            const baseStats = {
                hp: 15, mp: 15, armor: 3, spirit: 3, 
                attack: 1, magic: 2, grace: 0, fear: 0, materials: 0
            };
            
            let equippedItems = {
                weapon: null,
                armor: null,
                ring: null,
                accessory: null
            };


            // Drag-and-drop state
            let isDraggingEmoji = false;
            let draggedClone = null;
            let originalDraggedElement = null;
            
            // Helper function to shuffle an array
            const shuffle = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            };

            /**
             * Populates the results screen with collected items and winnings.
             */
            function populateResultsScreen() {
                // Clear previous summary data
                marketSummaryContainer.innerHTML = '';
                sellSummaryContainer.innerHTML = '';
                keepSummaryContainer.innerHTML = '';
                specialItemSummaryContainer.innerHTML = '';

                // Helper to create small summary squares
                const createSmallSquare = (item, sizeClasses) => {
                    const square = document.createElement('div');
                    // Added 'isolate' to create a stacking context so z-index works as expected.
                    square.className = `${sizeClasses} isolate relative flex-shrink-0 flex items-center justify-center rounded-md`;
                    square.textContent = item.emoji;
                    
                    const bgColor = (item.color && item.color !== 'rgba(0, 0, 0, 0)') ? item.color : '#4a5568';
                    square.style.backgroundColor = bgColor;

                    // If the color is yellow, add the class for the 2x indicator
                    if (bgColor === 'rgb(253, 224, 71)') { // Corresponds to yellow-300
                        square.classList.add('yellow-multiplier');
                    }

                    return square;
                };

                // Populate market items
                collectedMarketItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-16 h-16 text-4xl');
                    marketSummaryContainer.appendChild(square);
                });

                // Populate chosen special item
                if (chosenSpecialItem) {
                    specialItemSummaryContainer.textContent = chosenSpecialItem;
                }

                // Populate sell items
                collectedSellItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    sellSummaryContainer.appendChild(square);
                });

                // Populate keep items
                collectedKeepItems.forEach(item => {
                    const square = createSmallSquare(item, 'w-12 h-12 text-3xl');
                    keepSummaryContainer.appendChild(square);
                });

                // Populate gamble winnings
                gambleSummaryContainer.textContent = `$${totalWinnings}`;
            }

            /**
             * Animates the selling of items on the results screen.
             */
            function startResultsPhaseAnimations() {
                setTimeout(() => {
                    const sellSummarySquares = sellSummaryContainer.children;
                    let displayedWinnings = totalWinnings;

                    // Animate each square
                    Array.from(sellSummarySquares).forEach((square, index) => {
                        setTimeout(() => {
                            // Find the corresponding item from our data array
                            const item = collectedSellItems[index];
                            if (!item) return;

                            const baseSellValue = getEmojiSellValue(item.emoji);
                            const multiplier = getMultiplierFromColor(item.color);
                            const finalSellValue = baseSellValue * multiplier;

                            // Animate the emoji fading out
                            square.classList.add('transition-all', 'duration-500', 'transform', 'scale-125', 'opacity-0');

                            // After the emoji fades out, update winnings and show the value
                            setTimeout(() => {
                                // Update displayed winnings total
                                displayedWinnings += finalSellValue;
                                gambleSummaryContainer.textContent = `$${displayedWinnings}`;
                                
                                // Add a little pop to the winnings text
                                gambleSummaryContainer.classList.add('transform', 'scale-110', 'transition-transform', 'duration-200');
                                setTimeout(() => {
                                    gambleSummaryContainer.classList.remove('transform', 'scale-110');
                                }, 200);

                                // Change the square to display the value and fade it back in, preserving its size
                                square.textContent = `+$${finalSellValue}`;
                                square.classList.remove('text-3xl', 'scale-125'); // Keep w-12 h-12 and other size classes
                                square.classList.add('font-anton', 'text-lg', 'text-yellow-300', 'opacity-100');
                                square.style.backgroundColor = 'transparent';


                                // After the last animation, update the master winnings variable
                                if (index === sellSummarySquares.length - 1) {
                                    totalWinnings = displayedWinnings;
                                    console.log("Final total after selling:", totalWinnings);
                                }
                            }, 500);

                        }, index * 1000); // Stagger the animation
                    });
                }, 2000); // Wait 2 seconds before starting
            }
            
            /**
             * Helper to render a section of items without square borders and more compactly.
             */
            const createItemHTML = (counts) => {
                if (Object.keys(counts).length === 0) return '<p class="text-gray-500 text-center text-sm">Empty</p>';
                // Using 5 columns to make it more compact
                let html = `<div class="grid grid-cols-5 gap-1">`;
                for (const [emoji, count] of Object.entries(counts)) {
                    html += `
                        <div class="flex flex-col items-center">
                            <div class="w-8 h-8 flex items-center justify-center text-xl">${emoji}</div>
                            <span class="text-xs font-bold">x${count}</span>
                        </div>
                    `;
                }
                html += `</div>`;
                return html;
            };

            /**
             * Updates the stats display based on base stats and equipped items.
             */
            function updateStatsUI() {
                let currentStats = { ...baseStats };

                // Add bonuses from equipment
                if (equippedItems.weapon) currentStats.attack += 1;
                if (equippedItems.armor === '🧥') currentStats.armor += 1;
                if (equippedItems.ring === '💍') currentStats.grace += 1;

                // Update the DOM
                document.getElementById('hp-stat-value').textContent = currentStats.hp;
                document.getElementById('mp-stat-value').textContent = currentStats.mp;
                document.getElementById('armor-stat-value').textContent = currentStats.armor;
                document.getElementById('spirit-stat-value').textContent = currentStats.spirit;
                document.getElementById('attack-stat-value').textContent = currentStats.attack;
                document.getElementById('magic-stat-value').textContent = currentStats.magic;
                document.getElementById('grace-stat-value').textContent = currentStats.grace;
                document.getElementById('fear-stat-value').textContent = currentStats.fear;
                document.getElementById('materials-stat-value').textContent = currentStats.materials;
            }

            /**
             * Populates the inventory on the prepare screen.
             */
            function populatePrepareScreen() {
                const foodContent = document.getElementById('food-content');
                const inventoryContent = document.getElementById('inventory-content');
                foodContent.innerHTML = ''; 
                inventoryContent.innerHTML = '';

                // Helper to count item occurrences
                const countItems = (items) => {
                    const yellowColor = 'rgb(253, 224, 71)';
                    return items.reduce((acc, item) => {
                        if (item.emoji && item.emoji.trim() !== '') {
                            const quantity = item.color === yellowColor ? 2 : 1;
                            acc[item.emoji] = (acc[item.emoji] || 0) + quantity;
                        }
                        return acc;
                    }, {});
                };

                const marketCounts = countItems(collectedMarketItems);
                inventoryCounts = countItems(collectedKeepItems); // Store globally for this screen
                
                // Populate Food window with market items
                foodContent.innerHTML = createItemHTML(marketCounts);

                // Populate Inventory window with kept items
                inventoryContent.innerHTML = createItemHTML(inventoryCounts);

                // Set up equipment listeners and initial stats
                setupEquipmentScreen();
                updateStatsUI();
            }

            const EQUIPMENT_MAP = {
                weapon: { emojis: ['🏹', '🗡️', '🦴', '🪈'], title: 'Choose a Weapon' },
                armor: { emojis: ['🧥'], title: 'Choose Armor' },
                ring: { emojis: ['💍'], title: 'Choose a Ring' },
                accessory: { emojis: [], title: 'Choose an Accessory' }
            };

            /**
             * Handles the logic of equipping an item.
             */
            function equipItem(itemEmoji, itemType) {
                const slot = document.getElementById(`${itemType}-slot`);
                const inventoryContent = document.getElementById('inventory-content');

                // If an item of the same type is already equipped, return it to the inventory count
                if (equippedItems[itemType]) {
                    inventoryCounts[equippedItems[itemType]] = (inventoryCounts[equippedItems[itemType]] || 0) + 1;
                }

                // Equip the new item
                equippedItems[itemType] = itemEmoji;
                inventoryCounts[itemEmoji]--; // Decrement from inventory
                if (inventoryCounts[itemEmoji] === 0) {
                    delete inventoryCounts[itemEmoji]; // Remove if count is zero
                }

                // Update the UI
                slot.textContent = equippedItems[itemType];
                inventoryContent.innerHTML = createItemHTML(inventoryCounts); // Refresh inventory display
                updateStatsUI();
            }

            /**
             * Sets up the equipment window and its interactions.
             */
            function setupEquipmentScreen() {
                const modal = document.getElementById('equipment-modal');
                const modalTitle = document.getElementById('equipment-modal-title');
                const optionsContainer = document.getElementById('equipment-options');
                const closeModalButton = document.getElementById('close-equipment-modal');

                const openEquipModal = (itemType) => {
                    const config = EQUIPMENT_MAP[itemType];
                    const availableItems = config.emojis.filter(emoji => inventoryCounts[emoji] > 0);

                    if (availableItems.length > 0) {
                        modalTitle.textContent = config.title;
                        optionsContainer.innerHTML = ''; // Clear old options
                        
                        availableItems.forEach(emoji => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'flex flex-col items-center cursor-pointer p-2 bg-gray-700 rounded-md hover:bg-gray-600 transition-colors';
                            itemDiv.innerHTML = `
                                <div class="text-3xl">${emoji}</div>
                                <span class="text-xs font-bold mt-1">x${inventoryCounts[emoji]}</span>
                            `;
                            itemDiv.addEventListener('click', () => {
                                equipItem(emoji, itemType);
                                modal.classList.add('hidden');
                            });
                            optionsContainer.appendChild(itemDiv);
                        });
                        
                        modal.classList.remove('hidden');
                    } else {
                        console.log(`No items available for slot: ${itemType}`);
                    }
                };
                
                document.getElementById('weapon-slot').addEventListener('click', () => openEquipModal('weapon'));
                document.getElementById('armor-slot').addEventListener('click', () => openEquipModal('armor'));
                document.getElementById('ring-slot').addEventListener('click', () => openEquipModal('ring'));
                // document.getElementById('accessory-slot').addEventListener('click', () => openEquipModal('accessory'));

                closeModalButton.addEventListener('click', () => {
                    modal.classList.add('hidden');
                });
            }


            /**
             * Ends the gamble phase.
             */
            function endGamblePhase() {
                if (currentPhase !== 'gamble') return;
                currentPhase = 'results'; 
                
                clearInterval(gambleTimerInterval);
                gambleTimeLeft = 0;
                gambleCountdownElement.textContent = "0";
                spinButton.disabled = true;
                gambleToggle.disabled = true;
                
                console.log("Gamble phase over. Gambling winnings: $" + totalWinnings);
                
                // Transition to Results Screen
                populateResultsScreen();
                gambleScreen.classList.add('hidden');
                resultsScreen.classList.remove('hidden');
                resultsScreen.classList.add('flex');
                
                // Start the animations for the results phase
                startResultsPhaseAnimations();
            }

            /**
             * Starts the countdown timer for the gamble phase.
             */
            function startGambleTimer() {
                gambleCountdownElement.textContent = gambleTimeLeft;
                gambleTimerInterval = setInterval(() => {
                    gambleTimeLeft--;
                    gambleCountdownElement.textContent = gambleTimeLeft;

                    if (gambleTimeLeft <= 0) {
                        clearInterval(gambleTimerInterval);
                        endGamblePhase();
                    }
                }, 1000);
            }

            /**
             * Reveals the colors of the scavenge squares sequentially.
             */
            function startScavengeColorReveal() {
                const yellowColor = 'rgb(253, 224, 71)'; // yellow-300

                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 3) {
                        // Reveal one sell square
                        const sellSquareToColor = sellSquares[revealIndex];
                        const sellColor = scavengeSellColorPattern[revealIndex];
                        sellSquareToColor.style.backgroundColor = sellColor;
                        if (sellColor === yellowColor) {
                            sellSquareToColor.classList.add('yellow-multiplier');
                        }
                        
                        // Reveal one keep square
                        const keepSquareToColor = keepSquares[revealIndex];
                        const keepColor = scavengeKeepColorPattern[revealIndex];
                        keepSquareToColor.style.backgroundColor = keepColor;
                        if (keepColor === yellowColor) {
                            keepSquareToColor.classList.add('yellow-multiplier');
                        }

                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 4000); // Reveal every 4 seconds
            }

             /**
             * Transitions the game from the Scavenge to the Gamble screen.
             */
            function endScavengePhase() {
                if (currentPhase !== 'scavenge') return;
                
                // Force apply all scavenge colors to ensure they are set before proceeding.
                const yellowColor = 'rgb(253, 224, 71)'; // yellow-300
                sellSquares.forEach((square, index) => {
                    const finalColor = scavengeSellColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                keepSquares.forEach((square, index) => {
                    const finalColor = scavengeKeepColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                
                // Store collected scavenge items, filtering out any empty slots
                collectedSellItems = Array.from(sellSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');

                collectedKeepItems = Array.from(keepSquares).map(sq => ({
                    emoji: sq.textContent,
                    color: window.getComputedStyle(sq).backgroundColor
                })).filter(item => item.emoji.trim() !== '');


                currentPhase = 'gamble';
                clearInterval(scavengeTimerInterval);

                scavengeScreen.classList.add('hidden');
                gambleScreen.classList.remove('hidden');
                gambleScreen.classList.add('flex');
                
                // Initialize reels with random symbols
                reels.forEach(reel => {
                    reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                });

                startGambleTimer();
            }
            
            /**
             * Checks if all 6 scavenge squares are filled.
             */
            function checkAllTravelSquaresFilled() {
                let filledCount = 0;
                allTravelSquares.forEach(square => {
                    if (square.innerText.trim() !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allTravelSquares.length) {
                    endScavengePhase();
                }
            }


            /**
             * Starts the countdown timer for the scavenge phase.
             */
            function startScavengeTimer() {
                scavengeCountdownElement.textContent = scavengeTimeLeft;
                scavengeTimerInterval = setInterval(() => {
                    scavengeTimeLeft--;
                    scavengeCountdownElement.textContent = scavengeTimeLeft;

                    if (scavengeTimeLeft <= 0) {
                        clearInterval(scavengeTimerInterval);
                        endScavengePhase(); // End scavenge phase when time runs out
                    }
                }, 1000);
            }

            /**
             * Transitions the game from the Market to the Scavenge screen.
             */
            function endMarketPhase() {
                if (currentPhase !== 'market') return;

                // Clear any remaining special items if player didn't choose
                const specialItems = document.querySelectorAll('.special-item');
                specialItems.forEach(item => item.remove());
                
                // Force apply all market colors to ensure they are set before proceeding.
                const yellowColor = 'rgb(253, 224, 71)';
                fruitSquares.forEach((square, index) => {
                    const finalColor = marketFruitColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                vegSquares.forEach((square, index) => {
                    const finalColor = marketVegColorPattern[index];
                    square.style.backgroundColor = finalColor;
                    if (finalColor === yellowColor) {
                        square.classList.add('yellow-multiplier');
                    }
                });
                
                // Store collected market items
                collectedMarketItems = Array.from(allSquares).map(square => ({
                    emoji: square.textContent,
                    color: square.style.backgroundColor
                }));
                
                currentPhase = 'scavenge';

                // Stop all market-phase intervals
                clearInterval(marketTimerInterval);
                clearInterval(fruitSpawnInterval);
                clearInterval(vegSpawnInterval);

                // Clear any remaining emojis on the conveyor belts
                fruitConveyor.innerHTML = '';
                vegetableConveyor.innerHTML = '';
                
                // Hide market screen and show scavenge screen
                marketScreen.classList.add('hidden');
                scavengeScreen.classList.remove('hidden');
                scavengeScreen.classList.add('flex');
                
                // Generate and store the final color patterns for the scavenge squares
                const blueColor = 'rgb(59, 130, 246)'; // blue-500
                scavengeSellColorPattern = shuffle([blueColor, yellowColor, blueColor]);
                scavengeKeepColorPattern = shuffle([blueColor, yellowColor, blueColor]);

                // Start revealing scavenge square colors
                startScavengeColorReveal();

                // Start the scroll at the very bottom of the route
                scrollableRoute.scrollTop = scrollableRoute.scrollHeight;

                // Start the scavenge phase timer
                startScavengeTimer();
            }

             /**
             * Spawns the special choice emojis (wine and bread).
             */
            function spawnSpecialItems() {
                const gameArea = marketScreen.querySelector('main');
                
                const wineEmoji = document.createElement('div');
                wineEmoji.textContent = '🍷';
                wineEmoji.className = 'special-item';
                wineEmoji.style.left = '16.67%';

                const breadEmoji = document.createElement('div');
                breadEmoji.textContent = '🍞';
                breadEmoji.className = 'special-item';
                breadEmoji.style.left = '83.33%';

                const handleSpecialItemClick = (e) => {
                    chosenSpecialItem = e.target.textContent;
                    console.log(`Player chose: ${chosenSpecialItem}`);
                    wineEmoji.remove();
                    breadEmoji.remove();
                };

                wineEmoji.addEventListener('click', handleSpecialItemClick);
                breadEmoji.addEventListener('click', handleSpecialItemClick);

                gameArea.appendChild(wineEmoji);
                gameArea.appendChild(breadEmoji);
            }

            /**
             * Reveals the colors of the market squares sequentially.
             */
            function startColorReveal() {
                // Create shuffled lists of square indices to determine reveal order
                const fruitRevealOrder = shuffle([0, 1, 2, 3]);
                const vegRevealOrder = shuffle([0, 1, 2, 3]);
                const yellowColor = 'rgb(253, 224, 71)';

                let revealIndex = 0;
                const colorRevealInterval = setInterval(() => {
                    if (revealIndex < 4) {
                        // Reveal one fruit square based on the randomized reveal order
                        const fruitSquareIndex = fruitRevealOrder[revealIndex];
                        const fruitSquareToColor = fruitSquares[fruitSquareIndex];
                        const fruitColor = marketFruitColorPattern[fruitSquareIndex];
                        
                        fruitSquareToColor.style.backgroundColor = fruitColor;
                        if (fruitColor === yellowColor) {
                            fruitSquareToColor.classList.add('yellow-multiplier');
                        }

                        // Reveal one vegetable square based on the randomized reveal order
                        const vegSquareIndex = vegRevealOrder[revealIndex];
                        const vegSquareToColor = vegSquares[vegSquareIndex];
                        const vegColor = marketVegColorPattern[vegSquareIndex];
                        
                        vegSquareToColor.style.backgroundColor = vegColor;
                        if (vegColor === yellowColor) {
                            vegSquareToColor.classList.add('yellow-multiplier');
                        }
                        
                        revealIndex++;
                    } else {
                        clearInterval(colorRevealInterval);
                    }
                }, 3000);
            }

            /**
             * Starts the countdown timer for the market phase.
             */
            function startMarketTimer() {
                const blue = 'rgb(59, 130, 246)';
                const yellow = 'rgb(253, 224, 71)';

                // Generate and store the final color patterns for the market squares
                marketFruitColorPattern = shuffle([yellow, blue, blue, blue]);
                marketVegColorPattern = shuffle([yellow, blue, blue, blue]);

                // Start the staggered color reveal for market squares
                startColorReveal();

                marketTimerInterval = setInterval(() => {
                    marketTimeLeft--;
                    countdownElement.textContent = marketTimeLeft;

                    if (marketTimeLeft === 30) {
                        spawnSpecialItems();
                    }

                    if (marketTimeLeft <= 0) {
                        countdownElement.textContent = "0";
                        endMarketPhase(); // End game when timer hits zero
                    }
                }, 1000);
            }

            /**
             * Checks if all grid squares are filled.
             */
            function checkAllSquaresFilled() {
                let filledCount = 0;
                allSquares.forEach(square => {
                    if (square.innerText !== '') {
                        filledCount++;
                    }
                });

                if (filledCount === allSquares.length) {
                    endMarketPhase(); // End game when all squares are full
                }
            }


            /**
             * Handles the logic when a conveyor belt emoji is clicked.
             */
            function handleEmojiClick(emojiElement, type) {
                const squares = (type === 'fruit') ? fruitSquares : vegSquares;
                const emojiText = emojiElement.innerText;

                let equipped = false;
                for (const square of squares) {
                    if (square.innerText === '') {
                        square.innerText = emojiText;
                        equipped = true;
                        break; 
                    }
                }

                if (equipped) {
                    emojiElement.remove();
                    checkAllSquaresFilled(); // Check if the game should end
                }
            }

            /**
             * Creates and animates a single emoji on a conveyor belt.
             */
            function createEmoji(type) {
                const emojiEl = document.createElement('span');
                emojiEl.classList.add('emoji');

                const conveyor = type === 'fruit' ? fruitConveyor : vegetableConveyor;
                const emojiArray = type === 'fruit' ? fruits : vegetables;
                
                emojiEl.innerText = emojiArray[Math.floor(Math.random() * emojiArray.length)];

                const duration = 10;
                emojiEl.style.animationDuration = `${duration}s`;
                emojiEl.style.animationTimingFunction = 'linear';
                
                if (type === 'fruit') {
                    emojiEl.style.animationName = 'move-down';
                } else {
                    emojiEl.style.animationName = 'move-up';
                }
                
                emojiEl.addEventListener('click', () => handleEmojiClick(emojiEl, type));
                emojiEl.addEventListener('animationend', () => emojiEl.remove());

                conveyor.appendChild(emojiEl);
            }
            
            /**
             * Starts spawning emojis on the conveyor belts.
             */
            function startSpawning() {
                const spawnInterval = 1200; 
                fruitSpawnInterval = setInterval(() => createEmoji('fruit'), spawnInterval);
                vegSpawnInterval = setInterval(() => createEmoji('vegetable'), spawnInterval + 200); // Offset spawn times slightly
            }

            /**
             * Populates the travel route with 101 draggable symbol emojis.
             */
            function populateRoute() {
                for (let i = 0; i <= 100; i++) {
                    const emojiEl = document.createElement('div');
                    const randomEmoji = symbols[Math.floor(Math.random() * symbols.length)];
                    emojiEl.textContent = randomEmoji;
                    
                    emojiEl.classList.add('text-3xl', 'py-10', 'route-emoji');
                    emojiEl.draggable = true;
                    emojiEl.id = `route-emoji-${i}`;
                    
                    routeContent.appendChild(emojiEl);
                }
            }

            /**
             * Calculates winnings from the slot machine spin.
             */
            function calculateWinnings(finalReels) {
                // Clear previous glows from all reels
                reels.forEach(r => r.classList.remove('reel-win'));

                let win = 0;
                let winningIndices = [];

                // Helper to apply glow effect
                const applyGlow = (indices) => {
                    indices.forEach(index => reels[index].classList.add('reel-win'));
                    setTimeout(() => {
                        indices.forEach(index => reels[index].classList.remove('reel-win'));
                    }, 1000); // Glow lasts for 1 second
                };

                // Check for wins, from longest to shortest to ensure highest payout
                if (finalReels.every(s => s === finalReels[0])) { // 5 of a kind
                    win = 50;
                    winningIndices = [0, 1, 2, 3, 4];
                } else if (finalReels.slice(0, 4).every(s => s === finalReels[0])) { // 4 of a kind from reel 1
                    win = 20;
                    winningIndices = [0, 1, 2, 3];
                } else if (finalReels.slice(1, 5).every(s => s === finalReels[1])) { // 4 of a kind from reel 2
                    win = 20;
                    winningIndices = [1, 2, 3, 4];
                } else if (finalReels.slice(0, 3).every(s => s === finalReels[0])) { // 3 of a kind from reel 1
                    win = 10;
                    winningIndices = [0, 1, 2];
                } else if (finalReels.slice(1, 4).every(s => s === finalReels[1])) { // 3 of a kind from reel 2
                    win = 10;
                    winningIndices = [1, 2, 3];
                } else if (finalReels.slice(2, 5).every(s => s === finalReels[2])) { // 3 of a kind from reel 3
                    win = 10;
                    winningIndices = [2, 3, 4];
                }

                if (win > 0) {
                    hasWonGamble = true;
                    
                    if (!isUnlimitedWinsMode) {
                        // ONE 2X WIN MODE
                        win = win * 2;
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);
                        
                        winTracker.classList.add('scale-125', 'text-green-400');
                        // End the phase immediately after the win animation
                        setTimeout(() => {
                            endGamblePhase(); 
                        }, 1100); 

                    } else {
                        // UNLIMITED WINS MODE (original logic)
                        totalWinnings += win;
                        winTracker.textContent = `$${totalWinnings}`;
                        applyGlow(winningIndices);

                        winTracker.classList.add('scale-125', 'text-green-400');
                        setTimeout(() => {
                            winTracker.classList.remove('scale-125', 'text-green-400');
                        }, 500);
                    }
                    return true; // Indicate a win occurred
                }

                return false; // No win
            }

            /**
             * Handles the spinning of the slot machine reels.
             */
            function spinReels() {
                spinButton.disabled = true;
                gambleToggle.disabled = true; // Lock the gamble mode on the first spin

                let finalReels = [];

                reels.forEach((reel, index) => {
                    const spinDuration = 1000 + (index * 300); // Staggered stop time
                    const spinInterval = 50; // How fast the symbols flash

                    const intervalId = setInterval(() => {
                        reel.textContent = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                    }, spinInterval);

                    setTimeout(() => {
                        clearInterval(intervalId);
                        const finalSymbol = slotSymbols[Math.floor(Math.random() * slotSymbols.length)];
                        reel.textContent = finalSymbol;
                        finalReels[index] = finalSymbol;

                        // If this is the last reel to stop, calculate winnings and re-enable button
                        if (index === reels.length - 1) {
                            const hasWon = calculateWinnings(finalReels);
                            
                            // Do not re-enable button if game has ended or will end
                            if (isUnlimitedWinsMode || !hasWon) {
                                const reenableDelay = hasWon ? 1000 : 0; 
                                setTimeout(() => {
                                    if (gambleTimeLeft > 0) {
                                        spinButton.disabled = false;
                                    }
                                }, reenableDelay);
                            }
                        }
                    }, spinDuration);
                });
            }


            /**
             * Sets up both desktop and mobile drag-and-drop functionality.
             */
            function setupDragAndDrop() {
                // --- Desktop Drag Events ---
                routeContent.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        e.dataTransfer.setData('text/plain', e.target.textContent);
                        e.dataTransfer.setData('elementId', e.target.id);
                        e.dataTransfer.effectAllowed = 'move';
                        setTimeout(() => {
                            e.target.style.color = 'transparent';
                        }, 0);
                    }
                });

                routeContent.addEventListener('dragend', (e) => {
                    isDraggingEmoji = false;
                    if (e.target.classList.contains('route-emoji')) {
                        if (e.dataTransfer.dropEffect === 'none') {
                           e.target.style.color = '';
                        }
                    }
                });

                allTravelSquares.forEach(square => {
                    square.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (square.innerText.trim() === '') {
                             square.style.border = '2px dashed white';
                        }
                    });

                    square.addEventListener('dragleave', () => {
                        square.style.border = 'none';
                    });

                    square.addEventListener('drop', (e) => {
                        e.preventDefault();
                        square.style.border = 'none';
                        const emoji = e.dataTransfer.getData('text/plain');
                        if (square.innerText === '') {
                            square.innerText = emoji;
                            const elementId = e.dataTransfer.getData('elementId');
                            const draggedElement = document.getElementById(elementId);
                            if (draggedElement) {
                                draggedElement.draggable = false;
                                draggedElement.classList.remove('route-emoji');
                            }
                            checkAllTravelSquaresFilled();
                        }
                    });
                });

                // --- Mobile Touch Events ---
                function moveClone(x, y) {
                    if (draggedClone) {
                        draggedClone.style.left = `${x - draggedClone.offsetWidth / 2}px`;
                        draggedClone.style.top = `${y - draggedClone.offsetHeight / 2}px`;
                    }
                }

                routeContent.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('route-emoji')) {
                        isDraggingEmoji = true;
                        originalDraggedElement = e.target;
                        draggedClone = originalDraggedElement.cloneNode(true);
                        draggedClone.style.position = 'absolute';
                        draggedClone.style.zIndex = '1000';
                        draggedClone.style.pointerEvents = 'none';
                        document.body.appendChild(draggedClone);
                        
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);
                        
                        originalDraggedElement.style.color = 'transparent';
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (draggedClone) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        moveClone(touch.clientX, touch.clientY);

                        allTravelSquares.forEach(square => {
                            const rect = square.getBoundingClientRect();
                            if (touch.clientX > rect.left && touch.clientX < rect.right &&
                                touch.clientY > rect.top && touch.clientY < rect.bottom &&
                                square.innerText.trim() === '') {
                                square.style.border = '2px solid white';
                            } else {
                                square.style.border = 'none';
                            }
                        });
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (!draggedClone) return;

                    const touch = e.changedTouches[0];
                    let droppedSuccessfully = false;

                    for (const square of allTravelSquares) {
                        const rect = square.getBoundingClientRect();
                        if (touch.clientX > rect.left && touch.clientX < rect.right &&
                            touch.clientY > rect.top && touch.clientY < rect.bottom) {
                            
                            if (square.innerText === '') {
                                square.innerText = originalDraggedElement.innerText;
                                originalDraggedElement.draggable = false;
                                originalDraggedElement.classList.remove('route-emoji');
                                droppedSuccessfully = true;
                                checkAllTravelSquaresFilled();
                            }
                            break;
                        }
                    }

                    if (!droppedSuccessfully) {
                        originalDraggedElement.style.color = '';
                    }
                    
                    draggedClone.remove();
                    draggedClone = null;
                    originalDraggedElement = null;
                    isDraggingEmoji = false;
                    allTravelSquares.forEach(square => square.style.border = 'none');
                });
            }
            
            /**
             * Adds click-and-drag scrolling for desktop testing.
             */
            function setupDesktopScrolling() {
                let isDown = false;
                let startY;
                let scrollTop;

                scrollableRoute.addEventListener('mousedown', (e) => {
                    if (isDraggingEmoji || e.target.classList.contains('route-emoji')) return;

                    isDown = true;
                    scrollableRoute.classList.add('active');
                    startY = e.pageY - scrollableRoute.offsetTop;
                    scrollTop = scrollableRoute.scrollTop;
                });

                scrollableRoute.addEventListener('mouseleave', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mouseup', () => {
                    isDown = false;
                    scrollableRoute.classList.remove('active');
                });

                scrollableRoute.addEventListener('mousemove', (e) => {
                    if (!isDown || isDraggingEmoji) return;
                    e.preventDefault();
                    const y = e.pageY - scrollableRoute.offsetTop;
                    const walk = (y - startY) * 2;
                    scrollableRoute.scrollTop = scrollTop - walk;
                });
            }

            /**
             * Sets up the event listener for the gamble mode toggle switch.
             */
            function setupGambleToggle() {
                const updateToggleUI = () => {
                    isUnlimitedWinsMode = gambleToggle.checked;
                    if (isUnlimitedWinsMode) {
                        // Style for "UNLIMITED WINS" (checked) - Indigo toggle
                        unlimitedWinsLabel.classList.remove('text-gray-400');
                        unlimitedWinsLabel.classList.add('text-white');
                        oneWinLabel.classList.add('text-gray-400');
                        oneWinLabel.classList.remove('text-yellow-300');
                    } else {
                        // Style for "ONE 2X WIN" (unchecked) - Yellow toggle
                        oneWinLabel.classList.remove('text-gray-400');
                        oneWinLabel.classList.add('text-yellow-300');
                        unlimitedWinsLabel.classList.add('text-gray-400');
                        unlimitedWinsLabel.classList.remove('text-white');
                    }
                };

                gambleToggle.addEventListener('change', updateToggleUI);
                
                // Initialize UI based on default state when the script loads
                updateToggleUI();
            }

            // Initialize the game
            spinButton.addEventListener('click', spinReels);
            nextButton.addEventListener('click', () => {
                resultsScreen.classList.add('hidden');
                prepareScreen.classList.remove('hidden');
                prepareScreen.classList.add('flex');
                populatePrepareScreen();
            });

            // Add listeners for skip buttons
            skipMarketButton.addEventListener('click', endMarketPhase);
            skipScavengeButton.addEventListener('click', endScavengePhase);
            skipGambleButton.addEventListener('click', endGamblePhase);

            startMarketTimer();
            startSpawning();
            populateRoute();
            setupDesktopScrolling();
            setupDragAndDrop();
            setupGambleToggle();
        });
    </script>

</body>
</html>

